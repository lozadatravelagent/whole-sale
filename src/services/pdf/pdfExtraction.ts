import { parsePrice, resolveAirlineName, calculateFlightDuration, getCityNameFromCode } from './pdfParsingUtils';
import type { PdfAnalysisResult } from './pdfTypes';

/**
 * Check if PDF was generated by our PdfMonkey template
 */
export function isPdfMonkeyTemplate(fileName: string, content?: string): boolean {
    const pdfMonkeyPatterns = [
        /viaje-combinado-cotizacion/i,
        /wholesale-connect/i,
        /cotizacion.*pdf/i,
        /vuelos-cotizacion/i
    ];

    const filenameMatch = pdfMonkeyPatterns.some(pattern => pattern.test(fileName));
    if (filenameMatch) {
        return true;
    }

    if (content) {
        return isPdfMonkeyTemplateByContent(content);
    }

    return false;
}

/**
 * Detect PdfMonkey template by analyzing PDF content
 */
function isPdfMonkeyTemplateByContent(content: string): boolean {
    const templateIndicators = [
        /PRESUPUESTO DE VIAJE/i,
        /Para confirmar tu reserva.*contactanos por WhatsApp/i,
        /Documentaci√≥n y requisitos de ingreso.*responsabilidad del pasajero/i,
        /Tarifa sujeta a disponibilidad al momento de reservar/i,
        /DETALLE DEL VUELO/i,
        /Vuelo de ida.*Vuelo de regreso/i,
        /Equipaje de bodega incluido.*Carry On incluido/i,
        /wholesale-connect/i,
        /Tiempo de espera.*en.*\([A-Z]{3}\)/i,
        /adultos.*ni√±os/i
    ];

    const matchCount = templateIndicators.filter(pattern => pattern.test(content)).length;
    return matchCount >= 2;
}

/**
 * Extract structured data from our PdfMonkey template using real content
 */
export function extractPdfMonkeyDataFromContent(fileName: string, content: string): PdfAnalysisResult {
    console.log('üéØ Extracting structured data from PdfMonkey template content');

    const isCombinedTemplate = content.includes('PRESUPUESTO DE VIAJE') || content.includes('Hotel Recomendado');
    const hasFlightPatterns = /Vuelo de (ida|regreso)|adultos.*ni√±os|USD.*Precio total|Escala en|Tiempo de espera/i.test(content);
    const isRoundTrip = /Vuelo de ida/i.test(content) && /Vuelo de regreso/i.test(content);
    const hasLayovers = /Escala en/i.test(content);
    const isFlightsOnlyTemplate = hasFlightPatterns && !isCombinedTemplate;
    const needsComplexTemplate = isRoundTrip || hasLayovers;

    console.log('üìã Template detection:', {
        isCombinedTemplate,
        hasFlightPatterns,
        isRoundTrip,
        hasLayovers,
        isFlightsOnlyTemplate,
        needsComplexTemplate
    });

    console.log('üìã Template type detected:', isCombinedTemplate ? 'Combined (combined-flight-hotel.html)' :
        needsComplexTemplate ? 'Complex flights (flights-multiple.html)' :
            isFlightsOnlyTemplate ? 'Simple flights (flights-simple.html)' : 'Unknown');

    const flights = extractFlightsFromPdfMonkeyTemplate(content);
    const hotels = isCombinedTemplate ? extractHotelsFromPdfMonkeyTemplate(content) : [];

    let calculatedFlightPrice = 0;
    if (flights && flights.length > 0) {
        calculatedFlightPrice = flights.reduce((sum, flight) => sum + (flight.price || 0), 0);
        console.log('üí∞ Calculated flight price from individual flights:', calculatedFlightPrice);
    }

    let calculatedHotelPrice = 0;
    if (hotels && hotels.length > 0) {
        const arePackageOptions = hotels.length >= 2 &&
            hotels.every(h => /\(Opci√≥n\s+\d+\)/i.test(h.name));

        if (arePackageOptions) {
            calculatedHotelPrice = Math.min(...hotels.map(h => h.price));
            console.log('üí∞ [PACKAGE OPTIONS] Using cheapest hotel price:', calculatedHotelPrice, {
                hotels_count: hotels.length,
                allPrices: hotels.map(h => ({ name: h.name, price: h.price })),
                note: 'Options are mutually exclusive, not additive'
            });
        } else {
            calculatedHotelPrice = hotels.reduce((sum, hotel) => sum + hotel.price, 0);
            console.log('üí∞ Calculated hotel price (sum of all hotels):', calculatedHotelPrice, {
                hotels_count: hotels.length,
                hotels: hotels.map(h => ({ name: h.name, price: h.price, nights: h.nights }))
            });
        }
    }

    if (hotels && hotels.length >= 2 && calculatedFlightPrice > 0 && flights && flights.length > 0) {
        const cheapestHotelPrice = Math.min(...hotels.map(h => h.price));
        if (calculatedFlightPrice > cheapestHotelPrice) {
            const originalFlightPrice = calculatedFlightPrice;
            calculatedFlightPrice = calculatedFlightPrice - cheapestHotelPrice;
            console.log(`üîß [PRICE CORRECTION] Detected flight price was actually economic package price. Corrected from $${originalFlightPrice} to $${calculatedFlightPrice} (subtracted cheapest hotel: $${cheapestHotelPrice})`);

            const priceRatio = calculatedFlightPrice / originalFlightPrice;
            flights.forEach((flight, index) => {
                const correctedPrice = flight.price * priceRatio;
                console.log(`üîß [FLIGHT PRICE UPDATE] Flight ${index + 1}: $${flight.price.toFixed(2)} ‚Üí $${correctedPrice.toFixed(2)}`);
                flight.price = correctedPrice;
            });
        }
    }

    const extractedTotalPrice = extractTotalPriceFromPdfMonkeyTemplate(content);

    const totalPrice = (calculatedFlightPrice > 0 || calculatedHotelPrice > 0)
        ? calculatedFlightPrice + calculatedHotelPrice
        : extractedTotalPrice;

    console.log('üí∞ Final total price:', totalPrice, {
        flightPrice: calculatedFlightPrice,
        hotelPrice: calculatedHotelPrice,
        extractedPrice: extractedTotalPrice
    });

    const passengerInfo = extractPassengersFromPdfMonkeyTemplate(content);
    const currency = extractCurrencyFromPdfMonkeyTemplate(content);

    let destination: string | undefined;
    let arrivalCity: string | undefined;

    const flightRouteMatch = content.match(/DESTINO\s+([A-Z]{3})\s*[-‚Äì‚Äî]+\s*([A-Z]{3})(?=\s*FECHAS|\s*\d{4}|\s*$)/i);
    if (flightRouteMatch) {
        const originCode = flightRouteMatch[1].toUpperCase();
        const destCode = flightRouteMatch[2].toUpperCase();
        destination = `${originCode} -- ${destCode}`;
        arrivalCity = destCode;
        console.log('üìç [DESTINATION] Extracted flight route:', { origin: originCode, destination: destCode, arrivalCity });
    } else {
        const cityMatch = content.match(/DESTINO\s+([A-Z√ë√Å√â√ç√ì√ö][A-Za-z√Ä-√ø\s]+?)(?=\s*FECHAS|\s*\d{4}|\s*$)/i);
        if (cityMatch && cityMatch[1]) {
            destination = cityMatch[1].trim();
            arrivalCity = destination;
            console.log('üìç [DESTINATION] Extracted city name:', destination);
        }
    }

    if (arrivalCity && arrivalCity.length === 3) {
        const cityNameMatch = content.match(/estrellas\s+([A-Z√ë√Å√â√ç√ì√ö][A-Z√ë√Å√â√ç√ì√ö\s]+?)(?=\s+[a-z√±√°√©√≠√≥√∫]|\s+DOBLE|\s+SINGLE|\s+TRIPLE)/i);
        if (cityNameMatch && cityNameMatch[1]) {
            arrivalCity = cityNameMatch[1].trim();
            console.log('üìç [DESTINATION] Found full city name from hotel:', arrivalCity);
        }
    }

    if (hotels && hotels.length > 0 && arrivalCity) {
        hotels.forEach(hotel => {
            if (hotel.location === 'Ubicaci√≥n no especificada') {
                hotel.location = arrivalCity!;
                console.log(`üìç [DESTINATION] Applied fallback location to ${hotel.name}:`, arrivalCity);
            }
        });
    }

    const originalTemplate = isCombinedTemplate ?
        "3E8394AC-84D4-4286-A1CD-A12D1AB001D5" :
        needsComplexTemplate ?
            "30B142BF-1DD9-432D-8261-5287556DC9FC" :
            "67B7F3A5-7BFE-4F52-BE6B-110371CB9376";

    return {
        success: true,
        content: {
            flights,
            hotels,
            totalPrice,
            currency,
            passengers: passengerInfo.total,
            adults: passengerInfo.adults,
            childrens: passengerInfo.childrens,
            infants: passengerInfo.infants,
            destination,
            originalTemplate,
            needsComplexTemplate,
            extractedFromPdfMonkey: true
        },
        suggestions: [
            "Como este PDF fue generado por nuestro sistema, puedo regenerarlo con cualquier precio que especifiques",
            "Mantendr√© todos los detalles originales: vuelos, hoteles, fechas, pasajeros",
            "Solo cambiar√© los precios seg√∫n tu solicitud",
            "El nuevo PDF tendr√° la misma calidad y formato profesional"
        ]
    };
}

/**
 * Parse extracted PDF text to find travel information
 */
export function parseExtractedTravelData(text: string): PdfAnalysisResult['content'] {
    console.log('üîç Parsing extracted PDF text for travel data');
    console.log('üìÑ Full text to analyze:', text);

    const flights = extractFlightInfo(text);
    const hotels = extractHotelInfo(text);
    const totalPrice = extractTotalPrice(text);
    const passengers = extractPassengerCount(text);
    const currency = extractCurrency(text);

    console.log('üìä Extracted data summary:', {
        flights: flights.length,
        hotels: hotels.length,
        totalPrice,
        passengers,
        currency
    });

    return {
        flights,
        hotels,
        totalPrice,
        currency,
        passengers,
        extractedFromPdfMonkey: false
    };
}

// ===== PdfMonkey Template Extraction Functions =====

function extractFlightsFromPdfMonkeyTemplate(content: string): Array<{
    airline: string,
    route: string,
    price: number,
    dates: string,
    departureTime?: string,
    arrivalTime?: string,
    originCode?: string,
    destinationCode?: string,
    originCity?: string,
    destinationCity?: string,
    legs?: Array<{
        departure: { city_code: string, city_name: string, time: string },
        arrival: { city_code: string, city_name: string, time: string },
        duration: string,
        flight_type: string,
        airline?: string,
        price?: number,
        layovers?: Array<{
            destination_city: string,
            destination_code: string,
            waiting_time: string
        }>
    }>
}> {
    const flights: any[] = [];

    const extractAirlineName = (sectionContent: string): string => {
        console.log('üîç [AIRLINE EXTRACTION] Starting airline extraction...');

        const airlinePatterns = [
            /‚úà?\s*[Vv]uelos\s+([A-Z0-9]{2,3})\s+([A-Z][A-Za-z\s\.]+?)(?=\s+[A-Z][a-z]+|\s+[a-z]+|$)/m,
            /DETALLE\s+DEL\s+VUELO\s+([A-Z]{2,3})\s+([A-Z][A-Za-z\s√±√ë√°√©√≠√≥√∫√Å√â√ç√ì√ö\.]+?)(?:\s+Ocupaci√≥n)/i,
            /\n\s*([A-Z]{2,3})\s+([A-Z][A-Za-z\s√±√ë√°√©√≠√≥√∫√Å√â√ç√ì√ö\.]+?)\s+Ocupaci√≥n/i,
            /DETALLE\s+DEL\s+VUELO[^\n]*\n\s*([A-Z]{2,3})\s+([A-Za-z\s√±√ë√°√©√≠√≥√∫√Å√â√ç√ì√ö\.]+?)\s+Ocupaci√≥n/im,
            /^[^\n]{0,200}?([A-Z]{2,3})\s+([A-Z][A-Za-z\s]+)(?:\s+Ocupaci√≥n|\s+\d+\s+adultos)/im,
            /([A-Z]{2,3})\s+([A-Z][A-Z\s\.]+?(?:S\.A\.|INC\.|LTD\.|CORP\.|GROUP)?)\s+Ocupaci√≥n:/i,
            /([A-Z]{2,3})\s+([A-Z][A-Za-z\s\.\(\),&-]+?)\s+Ocupaci√≥n[:]/i,
            /([A-Z]{2,3})\s+([A-Z][^\n\r]+?)\s+Ocupaci√≥n[:]/i,
            /([A-Z]{2,3})\s+([A-Z][A-Za-z\s√±√ë√°√©√≠√≥√∫√Å√â√ç√ì√ö\.]+?)\s+Ocupaci√≥n/i,
        ];

        for (let i = 0; i < airlinePatterns.length; i++) {
            const match = sectionContent.match(airlinePatterns[i]);
            if (match) {
                console.log(`‚úÖ [AIRLINE EXTRACTION] Pattern ${i + 1} matched`);
                if (match[2]) {
                    const code = match[1].trim();
                    const name = match[2].trim();

                    if (i === 0) {
                        console.log(`‚úÖ [AIRLINE EXTRACTION] Found from "Vuelos" format: "${name}"`);
                        return name;
                    }

                    const fullName = `${code} ${name}`;
                    console.log(`‚úÖ [AIRLINE EXTRACTION] Found: "${fullName}"`);
                    return fullName;
                } else if (match[1]) {
                    const code = match[1].trim();
                    console.log(`‚úÖ [AIRLINE EXTRACTION] Found (code only): "${code}"`);
                    const resolved = resolveAirlineName(code);
                    console.log(`‚úÖ [AIRLINE EXTRACTION] Resolved to: "${resolved}"`);
                    return resolved;
                }
            } else {
                console.log(`‚ùå [AIRLINE EXTRACTION] Pattern ${i + 1} did not match`);
            }
        }

        console.warn('‚ö†Ô∏è [AIRLINE EXTRACTION] No patterns matched, returning default');
        return resolveAirlineName(undefined);
    };

    const airportPattern = /([A-Z]{3})\s+([A-Za-z√Ä-√ø\s]+?)\s+(\d{1,2}:\d{2})/g;
    const airportMatches = [...content.matchAll(airportPattern)];

    console.log('üîç Found airport matches:', airportMatches.map(m => ({
        code: m[1],
        city: m[2].trim(),
        time: m[3]
    })));

    const layoverPattern = /Escala en (.+?)\s+Tiempo de espera:\s*(\d+h\s*\d*m?)\s+en\s+([A-Z]{3})\s*\(([^)]+)\)/g;
    const layoverMatches = [...content.matchAll(layoverPattern)];

    console.log('üîç Found layover matches:', layoverMatches.map(m => ({
        city: m[1].trim(),
        waiting_time: m[2].trim(),
        code: m[3],
        full_city: m[4].trim()
    })));

    const legs: any[] = [];
    let originCode = '';
    let destinationCode = '';
    let departureTime = '';
    let arrivalTime = '';

    const hasOutbound = /Vuelo de ida/i.test(content);
    const hasReturn = /Vuelo de regreso/i.test(content);
    const isRoundTrip = hasOutbound && hasReturn;

    console.log('üîç Flight type analysis:', {
        hasOutbound,
        hasReturn,
        isRoundTrip,
        airportMatchesCount: airportMatches.length,
        layoverMatchesCount: layoverMatches.length
    });

    const priceMarkerPattern = /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD\s*Precio\s*total/gi;
    const priceMarkerMatches = [...content.matchAll(priceMarkerPattern)];

    console.log('üîç Found flight options (Precio total markers):', priceMarkerMatches.length);
    priceMarkerMatches.forEach((match, i) => {
        console.log(`  Match ${i + 1}: "${match[0]}" at position ${match.index}`);
    });

    if (priceMarkerMatches.length >= 2 || (isRoundTrip && airportMatches.length >= 4) || (isRoundTrip && airportMatches.length >= 2)) {
        console.log('üîç Processing round trip with flight details...');
        console.log('  isRoundTrip:', isRoundTrip, 'priceMarkers:', priceMarkerMatches.length, 'airports:', airportMatches.length);

        const flightSections: any[] = [];

        if (priceMarkerMatches.length === 0 && isRoundTrip) {
            console.log('üîç No price markers found, using entire content as single section');
            const returnFlightIndex = content.toLowerCase().indexOf('vuelo de regreso');

            if (returnFlightIndex > 0) {
                flightSections.push({
                    fullContent: content,
                    outboundContent: content.substring(0, returnFlightIndex),
                    returnContent: content.substring(returnFlightIndex)
                });
            } else {
                flightSections.push({
                    fullContent: content,
                    outboundContent: content,
                    returnContent: ''
                });
            }
        } else {
            for (let i = 0; i < priceMarkerMatches.length; i++) {
                let sectionStart: number;
                if (i === 0) {
                    sectionStart = 0;
                } else {
                    const previousMatchEnd = priceMarkerMatches[i - 1].index! + priceMarkerMatches[i - 1][0].length;
                    sectionStart = previousMatchEnd;
                }

                const sectionEnd = priceMarkerMatches[i + 1]?.index || content.length;
                const fullSection = content.substring(sectionStart, sectionEnd);
                const returnFlightIndex = fullSection.toLowerCase().indexOf('vuelo de regreso');

                if (returnFlightIndex > 0) {
                    flightSections.push({
                        fullContent: fullSection,
                        outboundContent: fullSection.substring(0, returnFlightIndex),
                        returnContent: fullSection.substring(returnFlightIndex)
                    });
                } else {
                    flightSections.push({
                        fullContent: fullSection,
                        outboundContent: fullSection,
                        returnContent: ''
                    });
                }
            }
        }

        console.log('üîç Processing', flightSections.length, 'flight section(s)');

        const legPrices: number[] = [];

        flightSections.forEach((section, sectionIndex) => {
            console.log(`üîç Processing section ${sectionIndex + 1}/${flightSections.length}`);

            const totalPricePattern = /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD\s*Precio\s*total/i;
            const totalPriceMatch = section.fullContent.match(totalPricePattern);
            let sectionTotalPrice = 0;

            console.log(`üîç Section ${sectionIndex + 1} fullContent preview:`, section.fullContent.substring(0, 150));

            if (totalPriceMatch) {
                sectionTotalPrice = parsePrice(totalPriceMatch[1]);
                console.log(`üí∞ [SECTION PRICE PARSE] Section ${sectionIndex + 1} "${totalPriceMatch[1]}" ‚Üí ${sectionTotalPrice} (ida + vuelta) from: "${totalPriceMatch[0]}"`);
            } else {
                console.warn(`‚ö†Ô∏è Section ${sectionIndex + 1}: Could not find price with pattern. Trying alternative...`);
                const fallbackPattern = /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/i;
                const fallbackMatch = section.fullContent.match(fallbackPattern);
                if (fallbackMatch) {
                    sectionTotalPrice = parsePrice(fallbackMatch[1]);
                    console.log(`üí∞ [SECTION FALLBACK PARSE] Section ${sectionIndex + 1} "${fallbackMatch[1]}" ‚Üí ${sectionTotalPrice}`);
                }
            }

            const sectionAirline = extractAirlineName(section.fullContent);
            console.log(`‚úàÔ∏è Section ${sectionIndex + 1} airline:`, sectionAirline);

            const sectionHasReturn = section.returnContent.trim().length > 0;
            const outboundPrice = sectionHasReturn ? sectionTotalPrice / 2 : sectionTotalPrice;
            const returnPrice = sectionHasReturn ? sectionTotalPrice / 2 : 0;

            console.log(`üí∞ Price for section ${sectionIndex + 1}: ${sectionHasReturn ? 'split' : 'full'} - outbound=$${outboundPrice}, return=$${returnPrice}`);

            const outboundAirportPattern = /([A-Z]{3})\s+([A-Za-z√Ä-√ø\s]+?)\s+(\d{1,2}:\d{2})/g;
            const outboundAirports = [...section.outboundContent.matchAll(outboundAirportPattern)];

            const returnAirportPattern = /([A-Z]{3})\s+([A-Za-z√Ä-√ø\s]+?)\s+(\d{1,2}:\d{2})/g;
            const returnAirports = [...section.returnContent.matchAll(returnAirportPattern)];

            console.log('üîç Section airports:', {
                outbound: outboundAirports.map(a => ({ code: a[1], city: a[2].trim(), time: a[3] })),
                return: returnAirports.map(a => ({ code: a[1], city: a[2].trim(), time: a[3] }))
            });

            const outboundLayoverPattern = /Escala en (.+?)\s+Tiempo de espera:\s*(\d+h\s*\d*m?)\s+en\s+([A-Z]{3})\s*\(([^)]+)\)/g;
            const outboundLayovers = [...section.outboundContent.matchAll(outboundLayoverPattern)];

            const returnLayoverPattern = /Escala en (.+?)\s+Tiempo de espera:\s*(\d+h\s*\d*m?)\s+en\s+([A-Z]{3})\s*\(([^)]+)\)/g;
            const returnLayovers = [...section.returnContent.matchAll(returnLayoverPattern)];

            if (outboundAirports.length >= 2) {
                const outboundOrigin = outboundAirports[0];
                const outboundDest = outboundAirports[outboundAirports.length - 1];

                const outboundLeg = {
                    departure: {
                        city_code: outboundOrigin[1],
                        city_name: outboundOrigin[2].trim(),
                        time: outboundOrigin[3]
                    },
                    arrival: {
                        city_code: outboundDest[1],
                        city_name: outboundDest[2].trim(),
                        time: outboundDest[3]
                    },
                    duration: calculateFlightDuration(outboundOrigin[3], outboundDest[3]) || '10h',
                    flight_type: 'outbound',
                    price: outboundPrice,
                    airline: sectionAirline,
                    layovers: outboundLayovers.map(layover => ({
                        destination_city: layover[4].trim(),
                        destination_code: layover[3],
                        waiting_time: layover[2].trim()
                    }))
                };

                legs.push(outboundLeg);
                legPrices.push(outboundPrice);
                console.log(`‚úÖ Outbound leg ${sectionIndex + 1} created: ${sectionAirline} - $${outboundPrice}`);
            }

            if (returnAirports.length >= 2) {
                const returnOrigin = returnAirports[0];
                const returnDest = returnAirports[returnAirports.length - 1];

                const returnLeg = {
                    departure: {
                        city_code: returnOrigin[1],
                        city_name: returnOrigin[2].trim(),
                        time: returnOrigin[3]
                    },
                    arrival: {
                        city_code: returnDest[1],
                        city_name: returnDest[2].trim(),
                        time: returnDest[3]
                    },
                    duration: calculateFlightDuration(returnOrigin[3], returnDest[3]) || '10h',
                    flight_type: 'return',
                    price: returnPrice,
                    airline: sectionAirline,
                    layovers: returnLayovers.map(layover => ({
                        destination_city: layover[4].trim(),
                        destination_code: layover[3],
                        waiting_time: layover[2].trim()
                    }))
                };

                legs.push(returnLeg);
                legPrices.push(returnPrice);
                console.log(`‚úÖ Return leg ${sectionIndex + 1} created: ${sectionAirline} - $${returnPrice}`);
            }
        });

        if (legs.length > 0) {
            const firstOutboundLeg = legs.find((leg: any) => leg.flight_type === 'outbound');
            if (firstOutboundLeg) {
                originCode = firstOutboundLeg.departure.city_code;
                destinationCode = firstOutboundLeg.arrival.city_code;
                departureTime = firstOutboundLeg.departure.time;
                arrivalTime = firstOutboundLeg.arrival.time;
            }
        }

    } else if (airportMatches.length >= 2) {
        originCode = airportMatches[0][1];
        departureTime = airportMatches[0][3];

        destinationCode = airportMatches[airportMatches.length - 1][1];
        arrivalTime = airportMatches[airportMatches.length - 1][3];

        const mainLeg: any = {
            departure: {
                city_code: originCode,
                city_name: airportMatches[0][2].trim(),
                time: departureTime
            },
            arrival: {
                city_code: destinationCode,
                city_name: airportMatches[airportMatches.length - 1][2].trim(),
                time: arrivalTime
            },
            duration: calculateFlightDuration(departureTime, arrivalTime) || '10h',
            flight_type: 'outbound',
            layovers: [] as any[]
        };

        if (layoverMatches.length > 0) {
            mainLeg.layovers = layoverMatches.map(layover => ({
                destination_city: layover[4].trim(),
                destination_code: layover[3],
                waiting_time: layover[2].trim()
            }));
        }

        legs.push(mainLeg);
    } else {
        console.log('üîç [ROUTE EXTRACTION] Using fallback route extraction...');
        console.log('üîç [ROUTE EXTRACTION] No structured airport+time matches found');
        console.log('üîç [ROUTE EXTRACTION] Looking for simple route patterns (XXX -- XXX)');

        const simpleRouteMatch = content.match(/([A-Z]{3})\s*(?:--|->|‚Üí|‚áÑ)\s*([A-Z]{3})/);
        if (simpleRouteMatch) {
            originCode = simpleRouteMatch[1];
            destinationCode = simpleRouteMatch[2];

            console.log(`‚úÖ [ROUTE EXTRACTION] Found simple route pattern: ${originCode} ‚Üí ${destinationCode}`);

            console.log(`üîç [ROUTE EXTRACTION] Looking for departure time for ${originCode}...`);
            const firstAirportTime = content.match(new RegExp(`${originCode}[^\\d]+(\\d{1,2}:\\d{2})`));
            if (firstAirportTime) {
                departureTime = firstAirportTime[1];
                console.log(`‚úÖ [ROUTE EXTRACTION] Found departure time: ${departureTime}`);
            } else {
                console.log(`‚ö†Ô∏è [ROUTE EXTRACTION] No departure time found for ${originCode}`);
            }

            console.log(`üîç [ROUTE EXTRACTION] Looking for arrival time for ${destinationCode}...`);
            const secondAirportTime = content.match(new RegExp(`${destinationCode}[^\\d]+(\\d{1,2}:\\d{2})`));
            if (secondAirportTime) {
                arrivalTime = secondAirportTime[1];
                console.log(`‚úÖ [ROUTE EXTRACTION] Found arrival time: ${arrivalTime}`);
            } else {
                console.log(`‚ö†Ô∏è [ROUTE EXTRACTION] No arrival time found for ${destinationCode}`);
            }

            legs.push({
                departure: {
                    city_code: originCode,
                    city_name: getCityNameFromCode(originCode),
                    time: departureTime || '08:00'
                },
                arrival: {
                    city_code: destinationCode,
                    city_name: getCityNameFromCode(destinationCode),
                    time: arrivalTime || '18:00'
                },
                duration: calculateFlightDuration(departureTime, arrivalTime) || '10h',
                flight_type: 'outbound',
                layovers: []
            });

            console.log(`‚úÖ [ROUTE EXTRACTION] Created fallback route: ${originCode} ‚Üí ${destinationCode}`);
        } else {
            console.error('‚ùå [ROUTE EXTRACTION] No route patterns found in content');
            console.log('üìÑ [ROUTE EXTRACTION] Content preview:', content.substring(0, 500));
        }
    }

    const outboundDateMatch = content.match(/Vuelo de ida\s+(\d{4}-\d{2}-\d{2})/i);
    const returnDateMatch = content.match(/Vuelo de regreso\s+(\d{4}-\d{2}-\d{2})/i);

    let departureDateStr = '2025-11-01';
    let returnDate: string | undefined = undefined;

    if (outboundDateMatch) {
        departureDateStr = outboundDateMatch[1];
    }

    if (returnDateMatch) {
        returnDate = returnDateMatch[1];
    }

    const priceMatches = content.match(/(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/i) ||
        content.match(/\$?\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:USD|US\$|\$)/gi);
    let price = 0;
    if (priceMatches) {
        const priceStr = priceMatches[0].match(/(\d{1,10}(?:[.,]\d{1,3})+|\d+)/);
        if (priceStr) {
            price = parsePrice(priceStr[1]);
            console.log(`üí∞ [FLIGHT LEG PRICE PARSE] "${priceStr[1]}" ‚Üí ${price}`);
        }
    }

    if (legs.length > 0) {
        const outboundLegs = legs.filter((leg: any) => leg.flight_type === 'outbound');
        const returnLegs = legs.filter((leg: any) => leg.flight_type === 'return');

        console.log('üîç Creating flight objects:', {
            outboundLegs: outboundLegs.length,
            returnLegs: returnLegs.length,
            isRoundTrip
        });

        if (isRoundTrip && returnLegs.length > 0) {
            const maxPairs = Math.max(outboundLegs.length, returnLegs.length);

            for (let i = 0; i < maxPairs; i++) {
                if (i < outboundLegs.length) {
                    const outboundLeg = outboundLegs[i];
                    flights.push({
                        airline: resolveAirlineName(outboundLeg.airline),
                        route: `${outboundLeg.departure.city_code} ‚Üí ${outboundLeg.arrival.city_code}`,
                        price: outboundLeg.price || 0,
                        dates: departureDateStr,
                        departureTime: outboundLeg.departure.time,
                        arrivalTime: outboundLeg.arrival.time,
                        originCode: outboundLeg.departure.city_code,
                        destinationCode: outboundLeg.arrival.city_code,
                        originCity: outboundLeg.departure.city_name,
                        destinationCity: outboundLeg.arrival.city_name,
                        legs: [outboundLeg]
                    });
                    console.log(`‚úÖ Created outbound flight ${i + 1}: ${outboundLeg.airline} - $${outboundLeg.price || 0}`);
                }

                if (i < returnLegs.length) {
                    const returnLeg = returnLegs[i];
                    flights.push({
                        airline: resolveAirlineName(returnLeg.airline),
                        route: `${returnLeg.departure.city_code} ‚Üí ${returnLeg.arrival.city_code}`,
                        price: returnLeg.price || 0,
                        dates: returnDate || departureDateStr,
                        departureTime: returnLeg.departure.time,
                        arrivalTime: returnLeg.arrival.time,
                        originCode: returnLeg.departure.city_code,
                        destinationCode: returnLeg.arrival.city_code,
                        originCity: returnLeg.departure.city_name,
                        destinationCity: returnLeg.arrival.city_name,
                        legs: [returnLeg]
                    });
                    console.log(`‚úÖ Created return flight ${i + 1}: ${returnLeg.airline} - $${returnLeg.price || 0}`);
                }
            }
        } else {
            outboundLegs.forEach((outboundLeg: any, i: number) => {
                flights.push({
                    airline: resolveAirlineName(outboundLeg.airline),
                    route: `${outboundLeg.departure.city_code} ‚Üí ${outboundLeg.arrival.city_code}`,
                    price: outboundLeg.price || 0,
                    dates: departureDateStr,
                    departureTime: outboundLeg.departure.time,
                    arrivalTime: outboundLeg.arrival.time,
                    originCode: outboundLeg.departure.city_code,
                    destinationCode: outboundLeg.arrival.city_code,
                    originCity: outboundLeg.departure.city_name,
                    destinationCity: outboundLeg.arrival.city_name,
                    legs: [outboundLeg]
                });
                console.log(`‚úÖ Created one-way flight ${i + 1}: ${outboundLeg.airline} - $${outboundLeg.price || 0}`);
            });
        }
    } else {
        const route = originCode && destinationCode ? `${originCode} ‚Üí ${destinationCode}` : 'Ruta no especificada';
        const dates = returnDate && returnDate !== departureDateStr ? `${departureDateStr} / ${returnDate}` : departureDateStr;

        let airlineName = resolveAirlineName(undefined);
        if (legs.length > 0 && legs[0].airline) {
            airlineName = resolveAirlineName(legs[0].airline);
        } else {
            const extracted = extractAirlineName(content);
            airlineName = resolveAirlineName(extracted);
            console.log('üîç Extracted airline for single flight:', airlineName);
        }

        flights.push({
            airline: airlineName,
            route,
            price,
            dates,
            departureTime: departureTime || undefined,
            arrivalTime: arrivalTime || undefined,
            originCode,
            destinationCode,
            originCity: getCityNameFromCode(originCode),
            destinationCity: getCityNameFromCode(destinationCode),
            legs: legs.length > 0 ? legs : undefined
        });
    }

    console.log('‚úàÔ∏è Extracted flights from PdfMonkey template:', flights);
    return flights;
}

function extractHotelsFromPdfMonkeyTemplate(content: string): Array<{
    name: string,
    location: string,
    price: number,
    nights: number,
    packagePrice?: number,
    category?: string,
    roomDescription?: string
}> {
    const hotels: Array<{
        name: string,
        location: string,
        price: number,
        nights: number,
        packagePrice?: number,
        category?: string,
        roomDescription?: string
    }> = [];

    const nightsMatch = content.match(/(\d+)\s*(?:Noche|Noches|noche|noches)/i);
    const nights = nightsMatch ? parseInt(nightsMatch[1]) : 0;

    console.log(`üè® [MULTI-HOTEL EXTRACTION] Starting extraction, nights: ${nights}`);

    const optionPattern = /Opci[o√≥]n\s+(1|2|\d+|Econ[o√≥]mica|Premium)\s+\$?(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/gi;
    const optionMatches = [...content.matchAll(optionPattern)];

    if (optionMatches.length >= 2) {
        console.log(`üì¶ [PACKAGE OPTIONS] Detected ${optionMatches.length} package options - using option-based extraction`);

        for (let i = 0; i < optionMatches.length; i++) {
            const optionMatch = optionMatches[i];
            const optionLabel = optionMatch[1];

            let optionNumber: number;
            if (optionLabel.match(/^(Econ[o√≥]mica)$/i)) {
                optionNumber = 1;
            } else if (optionLabel.match(/^Premium$/i)) {
                optionNumber = 2;
            } else {
                optionNumber = parseInt(optionLabel);
            }

            const packagePrice = parsePrice(optionMatch[2]);
            const optionEndPos = (optionMatch.index || 0) + optionMatch[0].length;

            const optionStartPos = i === 0
                ? 0
                : (optionMatches[i - 1].index || 0) + optionMatches[i - 1][0].length;

            const optionContent = content.substring(optionStartPos, optionEndPos);

            console.log(`üì¶ [OPTION ${optionNumber}] Extracting data (package price: $${packagePrice})`);

            let hotelName = 'Hotel no especificado';
            let stars = 0;

            const hotelPatterns = [
                /üè®\s*Hotel\s*\n?\s*([A-Z][A-Za-z\s\-\'\.]+?)\s+(\d+)\s*estrellas/i,
                /([A-Z][A-Za-z\s\-\'\.,]+?)\s+(\d+)\s*estrellas/i,
                /üè®\s*Hotel\s*\n?\s*([A-Z][A-Za-z\s\-\'\.]+?)(?=\s*(?:üìç|‚≠ê|DETALLE|Precio))/i
            ];

            for (const pattern of hotelPatterns) {
                const match = optionContent.match(pattern);
                if (match) {
                    hotelName = match[1].trim();
                    if (match[2]) {
                        stars = parseInt(match[2]);
                    }
                    break;
                }
            }

            let location = 'Ubicaci√≥n no especificada';

            const roomTypeKeywords = 'DOBLE|SINGLE|TRIPLE|CUADRUPLE|SUITE|STANDARD|ESTANDAR|EST√ÅNDAR|SUPERIOR|DELUXE|JUNIOR|COURTYARD|GARDEN|OCEAN|POOL|VIEW|KING|QUEEN|TWIN|HABITACION|HABITACI√ìN|ROOM|ADAPTED|CAPACITY|USO';

            const locationPatterns = [
                new RegExp(`(\\d+)\\s*[Ee]strellas\\s+([A-Z√ë√Å√â√ç√ì√ö]+(?:\\s+[A-Z√ë√Å√â√ç√ì√ö]+)*)(?=\\s+(?:${roomTypeKeywords}|[a-z√±√°√©√≠√≥√∫])|\\s*[Oo]pci[o√≥]n|\\s*‚úà|\\s*üöê|\\s*üè•|\\s*$)`),
                /(\d+)\s*estrellas\s*([A-Za-z√Ä-√ø\s,\(\)]+?)(?=\s*(?:DETALLE|Precio:|outbound|return))/i,
                /üìç\s*(?:Ubicaci√≥n:)?\s*([A-Za-z√Ä-√ø\s,\(\)]+?)(?=\s*(?:‚≠ê|üë•|DETALLE|Precio))/i
            ];

            for (const pattern of locationPatterns) {
                const match = optionContent.match(pattern);
                if (match) {
                    location = (match[2] || match[1]).trim();
                    break;
                }
            }

            let hotelPrice = 0;
            const hotelPricePattern = /(?:üè®\s*Hotel[\s\S]{0,300}?)Precio:\s*\$?\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/i;
            const hotelPriceMatch = optionContent.match(hotelPricePattern);
            if (hotelPriceMatch) {
                hotelPrice = parsePrice(hotelPriceMatch[1]);
            }

            let roomDescription: string | undefined;
            const roomDescPatterns = [
                /üõèÔ∏è\s*([^\n]+)/i,
                /(?:habitaci√≥n|room|hab\.?)\s*:?\s*([^\n]+)/i,
                /(\d+)\s*[Ee]strellas\s+[A-Z√ë√Å√â√ç√ì√ö]+(?:\s+[A-Z√ë√Å√â√ç√ì√ö]+)*\s+(.+?)(?=\s{2,}[Tt]raslado|\s{2,}[Ss]eguro|\s+DETALLE|\s*‚úà|$)/
            ];

            for (const pattern of roomDescPatterns) {
                const match = optionContent.match(pattern);
                if (match) {
                    let desc = (match[2] || match[1]).trim();
                    desc = desc.replace(/\s+(Traslado|Seguro|DETALLE).*$/i, '').trim();
                    if (desc && desc.length > 0) {
                        roomDescription = desc;
                        console.log(`üõèÔ∏è [ROOM DESC] Extracted for option ${optionNumber}:`, roomDescription);
                        break;
                    }
                }
            }

            const uniqueHotelName = `${hotelName} (Opci√≥n ${optionNumber})`;

            hotels.push({
                name: uniqueHotelName,
                location,
                price: hotelPrice,
                nights,
                packagePrice: packagePrice,
                category: stars > 0 ? String(stars) : undefined,
                roomDescription
            });

            console.log(`üì¶ [OPTION ${optionNumber} EXTRACTED]`, {
                name: uniqueHotelName,
                location,
                hotelPrice,
                packagePrice,
                nights,
                stars,
                roomDescription
            });
        }

        console.log(`‚úÖ [PACKAGE OPTIONS] Successfully extracted ${hotels.length} package options`);
        return hotels;
    }

    console.log(`üì¶ [PACKAGE OPTIONS] No multi-option pattern detected, using standard extraction`);

    const hotelNamePatterns = [
        /(?:üè®\s*)?Hotel\s*Recomendado\s+([A-Z][A-Z\s]+?)(?=\s*\d+\s*estrellas|DETALLE|Precio:|üè®\s*Hotel|üìç|‚≠ê)/gi,
        /üè®\s*Hotel\s*\n?\s*([A-Z][A-Za-z\s\-\'\.]+?)(?=\s*(?:üìç|‚≠ê|üë•|DETALLE|Tarifa|Para confirmar|Ocupaci√≥n|estrellas|\n\n|\nüè®))/gi,
        /([A-Z][A-Za-z\s\-\'\.,]+?)\s+(\d+)\s*estrellas/gi,
        /^([A-Z][A-Z\s]+(?:RESORT|HOTEL|BEACH|SUITES|INN|LODGE)[A-Z\s]*?)(?=\s*(?:üìç|‚≠ê|üë•|üè®|DETALLE|Tarifa|Para confirmar|Ocupaci√≥n|\n\n))/gim,
        /([A-Z]{2,}(?:\s+[A-Z]{2,}){1,4})(?=\s*(?:üìç|‚≠ê|üë•|üè®|DETALLE|Tarifa|Para confirmar|Ocupaci√≥n|Ubicaci√≥n|Precio|\d+\s*estrellas|\n\n))/g
    ];

    const foundHotels: Array<{ name: string, position: number, stars?: number }> = [];

    for (const pattern of hotelNamePatterns) {
        const matches = [...content.matchAll(pattern)];
        for (const match of matches) {
            const hotelName = match[1]?.trim();
            const starsVal = match[2] ? parseInt(match[2]) : undefined;

            if (hotelName && hotelName.length > 2) {
                const isDuplicate = foundHotels.some(h =>
                    h.name.toLowerCase() === hotelName.toLowerCase() ||
                    hotelName.toLowerCase().includes(h.name.toLowerCase()) ||
                    h.name.toLowerCase().includes(hotelName.toLowerCase())
                );

                const falsePositives = ['DETALLE', 'Precio', 'Ubicaci√≥n', 'Categor√≠a', 'Ocupaci√≥n', 'Tarifa', 'VUELO', 'VUELOS', 'ADULTOS', 'NI√ëOS', 'PASAJEROS', 'DURACI√ìN', 'INCLUYE', 'PRESUPUESTO', 'VIAJE', 'DESTINO', 'FECHAS'];
                const isFalsePositive = falsePositives.some(fp => hotelName.includes(fp));

                const minLength = 3;
                const isTooShort = hotelName.length < minLength;

                const hasHotelKeywords = /\b(RESORT|HOTEL|BEACH|SUITES|INN|LODGE|PALACE|GRAND|PLAZA|PARK|CLUB|VILLA)\b/i.test(hotelName);
                const isMultiWord = hotelName.trim().split(/\s+/).length >= 2;
                const looksLikeHotelName = hasHotelKeywords || isMultiWord;

                if (!isDuplicate && !isFalsePositive && !isTooShort && looksLikeHotelName) {
                    foundHotels.push({
                        name: hotelName,
                        position: match.index || 0,
                        stars: starsVal
                    });
                    console.log(`üè® [FOUND HOTEL] "${hotelName}" at position ${match.index}, stars: ${starsVal || 'N/A'}`);
                } else {
                    console.log(`üè® [SKIPPED] "${hotelName}" - duplicate: ${isDuplicate}, falsePositive: ${isFalsePositive}, tooShort: ${isTooShort}, looksLikeHotel: ${looksLikeHotelName}`);
                }
            }
        }
    }

    foundHotels.sort((a, b) => a.position - b.position);

    console.log(`üè® [MULTI-HOTEL] Found ${foundHotels.length} unique hotels:`, foundHotels.map(h => h.name));

    if (foundHotels.length === 0) {
        console.log(`üè® [FALLBACK] No hotels found with multi-pattern, trying original single-hotel extraction`);

        let hotelName = 'Hotel no especificado';
        const hotelNamePattern1 = /(?:üè®\s*)?Hotel\s*Recomendado\s+([A-Z][A-Z\s]+?)(?=\s*\d+\s*estrellas|DETALLE|Precio:|üè®\s*Hotel|üìç|‚≠ê)/i;
        const hotelNameMatch1 = content.match(hotelNamePattern1);
        if (hotelNameMatch1) {
            hotelName = hotelNameMatch1[1].trim();
            foundHotels.push({ name: hotelName, position: 0 });
        }
    }

    for (let i = 0; i < foundHotels.length; i++) {
        const hotelInfo = foundHotels[i];
        const hotelName = hotelInfo.name;

        const startPos = hotelInfo.position;
        const nextHotelPos = i < foundHotels.length - 1 ? foundHotels[i + 1].position : content.length;
        const hotelSection = content.substring(startPos, Math.min(startPos + 2000, nextHotelPos));

        console.log(`üè® [EXTRACTING HOTEL ${i + 1}] "${hotelName}" (section length: ${hotelSection.length})`);

        let location = 'Ubicaci√≥n no especificada';

        const locationPattern1 = /(\d+)\s*estrellas\s*([A-Za-z√Ä-√ø\s,]+?)(?=\s*(?:DETALLE|Precio:|üè®|üìç|‚≠ê|üë•|Tarifa|Para confirmar|Ocupaci√≥n))/i;
        const locationMatch1 = hotelSection.match(locationPattern1);
        if (locationMatch1) {
            location = locationMatch1[2].trim();
        } else {
            const locationPattern2 = /üìç\s*Ubicaci√≥n:\s*([A-Za-z√Ä-√ø\s,]+?)(?=\s*(?:‚≠ê|üë•|DETALLE|Tarifa|Para confirmar|Ocupaci√≥n|estrellas))/i;
            const locationMatch2 = hotelSection.match(locationPattern2);
            if (locationMatch2) {
                location = locationMatch2[1].trim();
            } else {
                const knownLocations = /([A-Z√Ä-≈∏][A-Za-z√Ä-√ø\s,]*(?:Punta\s+Cana|PUNTA\s+CANA|Buenos\s+Aires|BUENOS\s+AIRES|Madrid|Barcelona|Miami|Canc√∫n|CANC√öN|Rep√∫blica\s+Dominicana)[A-Za-z√Ä-√ø\s,]*?)(?=\s*(?:DETALLE|Precio:|üè®|üìç|‚≠ê|üë•|Tarifa|Ocupaci√≥n))/i;
                const locationMatch3 = hotelSection.match(knownLocations);
                if (locationMatch3) {
                    location = locationMatch3[1].trim();
                }
            }
        }

        let hotelPrice = 0;

        const pricePattern1 = /Precio:\s*\$?\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/i;
        const priceMatch1 = hotelSection.match(pricePattern1);
        if (priceMatch1) {
            hotelPrice = parsePrice(priceMatch1[1]);
            console.log(`üè® [HOTEL ${i + 1} PRICE] Pattern 1: "${priceMatch1[1]}" ‚Üí ${hotelPrice}`);
        }

        if (hotelPrice === 0) {
            const pricePattern2 = /Precio:\$?(\d{1,10}(?:[.,]\d{1,3})+|\d+)USD/i;
            const priceMatch2 = hotelSection.match(pricePattern2);
            if (priceMatch2) {
                hotelPrice = parsePrice(priceMatch2[1]);
                console.log(`üè® [HOTEL ${i + 1} PRICE] Pattern 2: "${priceMatch2[1]}" ‚Üí ${hotelPrice}`);
            }
        }

        if (hotelPrice === 0) {
            const allPricesInSection = [...hotelSection.matchAll(/(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/gi)];
            if (allPricesInSection.length > 0) {
                hotelPrice = parsePrice(allPricesInSection[0][1]);
                console.log(`üè® [HOTEL ${i + 1} PRICE] Pattern 3: "${allPricesInSection[0][1]}" ‚Üí ${hotelPrice}`);
            }
        }

        if (hotelPrice === 0 && i === 0) {
            const mainHotelSection = content.match(/Hotel Recomendado[\s\S]{0,500}?(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/i);
            if (mainHotelSection) {
                hotelPrice = parsePrice(mainHotelSection[1]);
                console.log(`üè® [HOTEL ${i + 1} PRICE] Fallback from main section: "${mainHotelSection[1]}" ‚Üí ${hotelPrice}`);
            }
        }

        let roomDescription: string | undefined;
        const roomDescPatterns = [
            /üõèÔ∏è\s*([^\n]+)/i,
            /(?:habitaci√≥n|room|hab\.?)\s*:?\s*([^\n]+)/i
        ];
        for (const pattern of roomDescPatterns) {
            const match = hotelSection.match(pattern);
            if (match && match[1]) {
                roomDescription = match[1].trim();
                break;
            }
        }

        hotels.push({
            name: hotelName,
            location,
            price: hotelPrice,
            nights,
            category: hotelInfo.stars ? String(hotelInfo.stars) : undefined,
            roomDescription
        });

        console.log(`üè® [HOTEL ${i + 1} EXTRACTED]`, {
            name: hotelName,
            location,
            price: hotelPrice,
            nights,
            stars: hotelInfo.stars,
            roomDescription
        });
    }

    if (hotels.length === 0) {
        console.log(`‚ö†Ô∏è [MULTI-HOTEL] No hotels extracted from PDF`);
    } else {
        console.log(`‚úÖ [MULTI-HOTEL] Successfully extracted ${hotels.length} hotel(s):`, hotels.map(h => h.name));
    }

    return hotels;
}

function extractTotalPriceFromPdfMonkeyTemplate(content: string): number {
    const totalPricePattern = /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD\s*Precio\s*total/gi;
    const totalMatches = [...content.matchAll(totalPricePattern)];

    if (totalMatches.length > 0) {
        const totalPrice = totalMatches.reduce((sum, match) => {
            const price = parsePrice(match[1]);
            console.log(`üí∞ [PRICE PARSE] "${match[1]}" ‚Üí ${price}`);
            return sum + price;
        }, 0);

        console.log('üí∞ Extracted total price from PdfMonkey template (from "Precio total"):', totalPrice,
            `(${totalMatches.length} price(s) found)`);
        return totalPrice;
    }

    const allPricePatterns = [
        /\$?(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*USD/g,
        /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:USD|US\$)/g
    ];

    const allPrices: number[] = [];
    for (const pattern of allPricePatterns) {
        const matches = [...content.matchAll(pattern)];
        matches.forEach(match => {
            const price = parsePrice(match[1]);
            if (!isNaN(price) && price > 0) {
                console.log(`üí∞ [FALLBACK PARSE] "${match[1]}" ‚Üí ${price}`);
                allPrices.push(price);
            }
        });
    }

    const totalPrice = allPrices.length > 0 ? Math.max(...allPrices) : 0;
    console.log('üí∞ Extracted total price from PdfMonkey template (fallback):', totalPrice, 'from prices:', allPrices);
    return totalPrice;
}

function extractPassengersFromPdfMonkeyTemplate(content: string): { adults: number; childrens: number; infants: number; total: number } {
    const adultMatch = content.match(/(\d+)\s*(?:Adulto|Adultos|adulto|adultos)/i);
    const childMatch = content.match(/(\d+)\s*(?:Ni√±o|Ni√±os|ni√±o|ni√±os)/i);
    const infantMatch = content.match(/(\d+)\s*(?:Infante|Infantes|infante|infantes|Beb√©|Beb√©s|beb√©|beb√©s)/i);

    const adults = adultMatch ? parseInt(adultMatch[1]) : 1;
    const childrens = childMatch ? parseInt(childMatch[1]) : 0;
    const infants = infantMatch ? parseInt(infantMatch[1]) : 0;
    const total = adults + childrens + infants;

    console.log('üë• Extracted passengers from PdfMonkey template:', { adults, childrens, infants, total });
    return { adults, childrens, infants, total };
}

function extractCurrencyFromPdfMonkeyTemplate(content: string): string {
    const currencyMatch = content.match(/\b(USD|US\$|EUR|ARS)\b/i);
    const currency = currencyMatch ? currencyMatch[1].toUpperCase().replace('US$', 'USD') : 'USD';
    console.log('üí± Extracted currency from PdfMonkey template:', currency);
    return currency;
}

// ===== Generic PDF Extraction Functions =====

function extractFlightInfo(text: string): Array<{
    airline: string,
    route: string,
    price: number,
    dates: string,
    departureTime?: string,
    arrivalTime?: string,
    originCode?: string,
    destinationCode?: string,
    originCity?: string,
    destinationCity?: string,
    legs?: Array<{
        from: string,
        to: string,
        departureTime?: string,
        arrivalTime?: string,
        flightNumber?: string
    }>
}> {
    const flights: Array<any> = [];

    const airlinePatterns = [
        /(?:LATAM|Aerol√≠neas Argentinas|American Airlines|United|Delta|Air France|Iberia|AVIANCA|JetSmart|Flybondi|Copa Airlines|LAN|TAM|Avianca|Iberia|Air France|British Airways|Lufthansa|KLM|Alitalia|Swiss|Austrian)/gi,
        /(?:AA|UA|DL|AF|IB|AV|LAN|TAM|CM|BA|LH|KL|AZ|LX|OS)/gi
    ];

    const routePatterns = [
        /([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})/g,
        /([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})/g,
        /(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York|London|Paris|Rome|Amsterdam|Frankfurt|S√£o Paulo|R√≠o de Janeiro|Lima|Bogot√°|Santiago|M√©xico|Toronto|Montreal)\s*[-‚Äì‚Üí‚Üí‚Üí]\s*(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York|London|Paris|Rome|Amsterdam|Frankfurt|S√£o Paulo|R√≠o de Janeiro|Lima|Bogot√°|Santiago|M√©xico|Toronto|Montreal)/gi,
        /(Ezeiza|Jorge Newbery|Aeroparque|Barajas|El Prat|Miami International|Punta Cana International|Canc√∫n International|John F\. Kennedy|LaGuardia|Newark|Heathrow|Gatwick|Charles de Gaulle|Orly|Fiumicino|Ciampino|Schiphol|Frankfurt|Zurich|Vienna|Guarulhos|Gale√£o|Jorge Ch√°vez|El Dorado|Arturo Merino Ben√≠tez|Benito Ju√°rez|Pearson|Trudeau)/gi
    ];

    const datePatterns = [
        /(\d{1,2})\/(\d{1,2})\/(\d{4})\s*[-‚Äì]\s*(\d{1,2})\/(\d{1,2})\/(\d{4})/g,
        /(\d{1,2})\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)\s+(\d{4})\s*[-‚Äì]\s*(\d{1,2})\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)\s+(\d{4})/gi,
        /(\d{4})-(\d{2})-(\d{2})\s*[-‚Äì]\s*(\d{4})-(\d{2})-(\d{2})/g
    ];

    const timePatterns = [
        /(\d{1,2}):(\d{2})\s*[-‚Äì]\s*(\d{1,2}):(\d{2})/g,
        /(?:salida|departure|dep).*?(\d{1,2}):(\d{2})/gi,
        /(?:llegada|arrival|arr).*?(\d{1,2}):(\d{2})/gi,
        /(\d{1,2}):(\d{2})\s*(?:AM|PM|am|pm)?/g
    ];

    const flightNumberPatterns = [
        /(?:vuelo|flight|voo)\s*(?:n[o¬∫¬∞]?\.?\s*)?([A-Z]{2}\d{2,4})/gi,
        /([A-Z]{2}\s?\d{2,4})/g
    ];

    const pricePatterns = [
        /(?:USD|US\$|\$)\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)/gi,
        /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:USD|US\$|\$)/gi
    ];

    const airlines: string[] = [];
    for (const pattern of airlinePatterns) {
        const matches = [...text.matchAll(pattern)];
        airlines.push(...matches.map(m => m[0]));
    }

    const routes: string[] = [];
    const routeDetails: any[] = [];
    for (const pattern of routePatterns) {
        const matches = [...text.matchAll(pattern)];
        routes.push(...matches.map(m => m[0]));

        matches.forEach(match => {
            if (match.length >= 3) {
                const origin = match[1];
                const destination = match[3] || match[2];
                const connection = match[3] ? match[2] : null;
                routeDetails.push({ origin, destination, connection, fullRoute: match[0] });
            } else if (match.length >= 2) {
                routeDetails.push({
                    origin: match[1],
                    destination: match[2],
                    connection: null,
                    fullRoute: match[0]
                });
            }
        });
    }

    const dates: string[] = [];
    for (const pattern of datePatterns) {
        const matches = [...text.matchAll(pattern)];
        dates.push(...matches.map(m => m[0]));
    }

    const times: string[] = [];
    const departureTimes: string[] = [];
    const arrivalTimes: string[] = [];
    for (const pattern of timePatterns) {
        const matches = [...text.matchAll(pattern)];
        times.push(...matches.map(m => m[0]));

        matches.forEach(match => {
            if (match.length >= 4) {
                departureTimes.push(`${match[1]}:${match[2]}`);
                arrivalTimes.push(`${match[3]}:${match[4]}`);
            } else if (match.length >= 3) {
                times.push(`${match[1]}:${match[2]}`);
            }
        });
    }

    const flightNumbers: string[] = [];
    for (const pattern of flightNumberPatterns) {
        const matches = [...text.matchAll(pattern)];
        flightNumbers.push(...matches.map(m => m[1] || m[0]));
    }

    const prices: number[] = [];
    for (const pattern of pricePatterns) {
        const matches = [...text.matchAll(pattern)];
        prices.push(...matches.map(m => {
            const priceStr = m[1] || m[0];
            const price = parsePrice(priceStr);
            console.log(`üí∞ [FLIGHT INFO PARSE] "${priceStr}" ‚Üí ${price}`);
            return price;
        }));
    }

    if (airlines.length === 0 && routes.length === 0) {
        console.log('‚úàÔ∏è No airlines or routes found - skipping flight extraction (prices may be from hotels)');
        return [];
    }

    const maxEntries = Math.max(airlines.length, routes.length, dates.length, prices.length, 1);

    for (let i = 0; i < maxEntries; i++) {
        const routeDetail = routeDetails[i];
        const flight: any = {
            airline: resolveAirlineName(airlines[i]),
            route: routes[i] || 'Ruta no especificada',
            price: prices[i] || 0,
            dates: dates[i] || 'Fechas no especificadas',
            departureTime: departureTimes[i],
            arrivalTime: arrivalTimes[i],
            originCode: routeDetail?.origin,
            destinationCode: routeDetail?.destination,
            originCity: getCityNameFromCode(routeDetail?.origin || ''),
            destinationCity: getCityNameFromCode(routeDetail?.destination || ''),
            legs: [] as any[]
        };

        if (routeDetail) {
            flight.legs.push({
                from: routeDetail.origin,
                to: routeDetail.connection || routeDetail.destination,
                departureTime: departureTimes[i * 2],
                arrivalTime: arrivalTimes[i * 2],
                flightNumber: flightNumbers[i * 2]
            });

            if (routeDetail.connection) {
                flight.legs.push({
                    from: routeDetail.connection,
                    to: routeDetail.destination,
                    departureTime: departureTimes[i * 2 + 1],
                    arrivalTime: arrivalTimes[i * 2 + 1],
                    flightNumber: flightNumbers[i * 2 + 1]
                });
            }

            if (dates[i] && dates[i].includes('-') || dates[i].includes('/')) {
                flight.legs.push({
                    from: routeDetail.destination,
                    to: routeDetail.connection || routeDetail.origin,
                    departureTime: departureTimes[i * 2 + 2],
                    arrivalTime: arrivalTimes[i * 2 + 2],
                    flightNumber: flightNumbers[i * 2 + 2]
                });

                if (routeDetail.connection) {
                    flight.legs.push({
                        from: routeDetail.connection,
                        to: routeDetail.origin,
                        departureTime: departureTimes[i * 2 + 3],
                        arrivalTime: arrivalTimes[i * 2 + 3],
                        flightNumber: flightNumbers[i * 2 + 3]
                    });
                }
            }
        }

        flights.push(flight);
    }

    console.log('‚úàÔ∏è Extracted flights:', flights);
    return flights.slice(0, 3);
}

function extractHotelInfo(text: string): Array<{ name: string, location: string, price: number, nights: number, category?: string, roomDescription?: string }> {
    const hotels: Array<{ name: string, location: string, price: number, nights: number, category?: string, roomDescription?: string }> = [];

    const hotelPatterns = [
        /(?:Hotel|Resort|Aparthotel|Inn|Lodge|Suites?)\s+([A-Za-z\s]+)/gi,
        /([A-Za-z\s]+)\s+(?:Hotel|Resort|Aparthotel|Inn|Lodge|Suites?)/gi
    ];

    const locationPatterns = [
        /(Punta Cana|Canc√∫n|Miami|Madrid|Barcelona|Buenos Aires|R√≠o de Janeiro|S√£o Paulo)/gi,
        /(?:en|in)\s+([A-Za-z\s]+)/gi
    ];

    const nightlyRatePatterns = [
        /(\d+)\s*(?:USD|US\$|\$)\s*(?:por noche|per night|\/night)/gi,
        /(?:por noche|per night|\/night)\s*(\d+)\s*(?:USD|US\$|\$)/gi
    ];

    const nightsPatterns = [
        /(\d+)\s*(?:noches?|nights?)/gi,
        /(?:noches?|nights?)\s*(\d+)/gi
    ];

    const starsPattern = /(\d+)\s*(?:estrellas?|stars?|\*)/gi;

    const roomDescPatterns = [
        /üõèÔ∏è\s*([^\n]+)/gi,
        /(?:habitaci√≥n|room|hab\.?)\s*:?\s*([^\n,]+(?:doble|single|triple|individual|twin|suite|standard|superior|deluxe)[^\n,]*)/gi,
        /(?:doble|single|triple|individual|twin|suite|standard|superior|deluxe)\s+[^\n,]+(?:uso\s+(?:individual|doble|triple))?[^\n,]*/gi
    ];

    const hotelNames: string[] = [];
    for (const pattern of hotelPatterns) {
        const matches = [...text.matchAll(pattern)];
        hotelNames.push(...matches.map(m => m[1]?.trim()).filter(Boolean));
    }

    const locations: string[] = [];
    for (const pattern of locationPatterns) {
        const matches = [...text.matchAll(pattern)];
        locations.push(...matches.map(m => m[1]?.trim()).filter(Boolean));
    }

    const nightlyRates: number[] = [];
    for (const pattern of nightlyRatePatterns) {
        const matches = [...text.matchAll(pattern)];
        nightlyRates.push(...matches.map(m => parseFloat(m[1])));
    }

    const nightsArray: number[] = [];
    for (const pattern of nightsPatterns) {
        const matches = [...text.matchAll(pattern)];
        nightsArray.push(...matches.map(m => parseInt(m[1])));
    }

    const starsArray: number[] = [];
    const starsMatches = [...text.matchAll(starsPattern)];
    starsArray.push(...starsMatches.map(m => parseInt(m[1])).filter(n => n >= 1 && n <= 5));

    const roomDescriptions: string[] = [];
    for (const pattern of roomDescPatterns) {
        const matches = [...text.matchAll(pattern)];
        roomDescriptions.push(...matches.map(m => (m[1] || m[0])?.trim()).filter(Boolean));
    }
    console.log('üõèÔ∏è Extracted room descriptions:', roomDescriptions);

    const maxEntries = Math.max(hotelNames.length, locations.length, nightlyRates.length, nightsArray.length, 1);

    for (let i = 0; i < maxEntries; i++) {
        hotels.push({
            name: hotelNames[i] || 'Hotel no especificado',
            location: locations[i] || 'Ubicaci√≥n no especificada',
            price: nightlyRates[i] || 0,
            nights: nightsArray[i] || 0,
            category: starsArray[i] ? String(starsArray[i]) : undefined,
            roomDescription: roomDescriptions[i] || undefined
        });
    }

    console.log('üè® Extracted hotels:', hotels);
    return hotels.slice(0, 3);
}

function extractTotalPrice(text: string): number {
    console.log('üí∞ Searching for total price in text...');

    const totalPatterns = [
        /(?:total|precio total|total price|grand total|total general|precio final|monto total|importe total)\s*:?\s*(?:USD|US\$|\$)?\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)/gi,
        /(?:USD|US\$|\$)\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:total|precio total|total price|grand total)/gi,
        /\$\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:USD|usd)?/gi,
        /(\d{1,10}(?:[.,]\d{1,3})+|\d+)\s*(?:USD|US\$|\$)/gi,
        /(?:precio|price|total|costo|cost)\s*:?\s*\$?\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)/gi,
        /(?:USD|US\$|\$)\s*(\d{1,10}(?:[.,]\d{1,3})+|\d+)/gi
    ];

    let bestMatch = { price: 0, confidence: 0 };

    for (const pattern of totalPatterns) {
        const matches = [...text.matchAll(pattern)];
        console.log(`üí∞ Pattern "${pattern.source}" found ${matches.length} matches`);

        for (const match of matches) {
            const priceStr = match[1] || match[0];
            const price = parsePrice(priceStr);

            if (!isNaN(price) && price > 0 && price < 50000) {
                console.log(`üí∞ [EXTERNAL PDF PARSE] "${priceStr}" ‚Üí ${price} from match: "${match[0]}"`);
                const confidence = match[0].toLowerCase().includes('total') ? 2 : 1;

                if (confidence > bestMatch.confidence || (confidence === bestMatch.confidence && price > bestMatch.price)) {
                    bestMatch = { price, confidence };
                }
            }
        }
    }

    if (bestMatch.price > 0) {
        console.log('üí∞ Final extracted total price:', bestMatch.price, 'confidence:', bestMatch.confidence);
        return bestMatch.price;
    }

    console.log('üí∞ No total price found');
    return 0;
}

function extractPassengerCount(text: string): number {
    const passengerPatterns = [
        /(\d+)\s*(?:pasajeros?|passengers?|adultos?|adults?|personas?|people)/gi,
        /(?:pasajeros?|passengers?|adultos?|adults?|personas?|people)\s*:?\s*(\d+)/gi
    ];

    for (const pattern of passengerPatterns) {
        const match = text.match(pattern);
        if (match) {
            const count = parseInt(match[1]);
            if (!isNaN(count) && count > 0) {
                console.log('üë• Extracted passenger count:', count);
                return count;
            }
        }
    }

    console.log('üë• No passenger count found, defaulting to 1');
    return 1;
}

function extractCurrency(text: string): string {
    const currencyPatterns = [
        /\b(USD|US\$|EUR|ARS|BRL)\b/gi,
        /\$([\d,]+(?:\.\d{2})?)/g
    ];

    for (const pattern of currencyPatterns) {
        const match = text.match(pattern);
        if (match) {
            const currency = match[1]?.toUpperCase() || 'USD';
            console.log('üí± Extracted currency:', currency);
            return currency === 'US$' ? 'USD' : currency;
        }
    }

    console.log('üí± No currency found, defaulting to USD');
    return 'USD';
}
