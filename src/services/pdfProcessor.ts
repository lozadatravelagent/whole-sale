/**
 * PDF Processor Service
 * Handles PDF upload, reading, and content analysis for travel quotations
 */

import { supabase } from '@/integrations/supabase/client';
import { searchAirFares, type AirfareSearchParams } from './airfareSearch';
import type { FlightData } from '@/types';

export interface PdfAnalysisResult {
    success: boolean;
    content?: {
        flights?: Array<{
            airline: string;
            route: string;
            price: number;
            dates: string;
        }>;
        hotels?: Array<{
            name: string;
            location: string;
            price: number;
            nights: number;
        }>;
        totalPrice?: number;
        currency?: string;
        passengers?: number;
        originalTemplate?: string;
        extractedFromPdfMonkey?: boolean;
    };
    suggestions?: string[];
    error?: string;
}

export interface PdfUploadResult {
    success: boolean;
    url?: string;
    error?: string;
}

export interface CheaperFlightSearchResult {
    success: boolean;
    originalFlights?: Array<{
        airline: string;
        route: string;
        price: number;
        dates: string;
    }>;
    alternativeFlights?: FlightData[];
    savings?: number;
    message?: string;
    error?: string;
}

/**
 * Upload PDF file to Supabase storage
 */
export async function uploadPdfFile(file: File, conversationId: string): Promise<PdfUploadResult> {
    try {
        const fileName = `pdf-uploads/${conversationId}/${Date.now()}-${file.name}`;

        const { data, error } = await supabase.storage
            .from('documents')
            .upload(fileName, file, {
                cacheControl: '3600',
                upsert: false
            });

        if (error) {
            console.error('Error uploading PDF:', error);
            return {
                success: false,
                error: error.message
            };
        }

        // Get public URL
        const { data: urlData } = supabase.storage
            .from('documents')
            .getPublicUrl(fileName);

        return {
            success: true,
            url: urlData.publicUrl
        };

    } catch (error) {
        console.error('Error in uploadPdfFile:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
        };
    }
}

/**
 * Check if PDF was generated by our PdfMonkey template
 */
function isPdfMonkeyTemplate(fileName: string, content?: string): boolean {
    // Check filename patterns that suggest it's our generated PDF
    const pdfMonkeyPatterns = [
        /viaje-combinado-cotizacion/i,
        /wholesale-connect/i,
        /cotizacion.*pdf/i,
        /vuelos-cotizacion/i
    ];

    // First check filename
    const filenameMatch = pdfMonkeyPatterns.some(pattern => pattern.test(fileName));
    if (filenameMatch) {
        return true;
    }

    // If content is available, check for template-specific patterns
    if (content) {
        return isPdfMonkeyTemplateByContent(content);
    }

    return false;
}

/**
 * Detect PdfMonkey template by analyzing PDF content
 */
function isPdfMonkeyTemplateByContent(content: string): boolean {
    // Patterns that are unique to our templates
    const templateIndicators = [
        // From both.html template
        /PRESUPUESTO DE VIAJE/i,
        /Para confirmar tu reserva.*contactanos por WhatsApp/i,
        /Documentaci√≥n y requisitos de ingreso.*responsabilidad del pasajero/i,
        /Tarifa sujeta a disponibilidad al momento de reservar/i,

        // From flights.html template  
        /DETALLE DEL VUELO/i,
        /Vuelo de ida.*Vuelo de regreso/i,
        /Equipaje de bodega incluido.*Carry On incluido/i,

        // General template patterns
        /wholesale-connect/i,
        /Tiempo de espera.*en.*\([A-Z]{3}\)/i, // Layover pattern
        /adultos.*ni√±os/i // Passenger pattern
    ];

    // Check if content contains multiple template indicators
    const matchCount = templateIndicators.filter(pattern => pattern.test(content)).length;

    // If we find 2 or more indicators, it's likely our template
    return matchCount >= 2;
}

/**
 * Extract structured data from our PdfMonkey template using real content
 * Since we know the exact structure, we can extract data more precisely
 */
function extractPdfMonkeyDataFromContent(fileName: string, content: string): PdfAnalysisResult {
    console.log('üéØ Extracting structured data from PdfMonkey template content');

    // Determine which template was used based on content
    const isCombinedTemplate = content.includes('PRESUPUESTO DE VIAJE') || content.includes('Hotel Recomendado');

    // More flexible detection for flights template - look for flight-related patterns
    const hasFlightPatterns = /Vuelo de (ida|regreso)|adultos.*ni√±os|USD.*Precio total|Escala en|Tiempo de espera/i.test(content);
    const isFlightsOnlyTemplate = hasFlightPatterns && !isCombinedTemplate;

    console.log('üìã Template type detected:', isCombinedTemplate ? 'Combined (both.html)' : isFlightsOnlyTemplate ? 'Flights only (flights.html)' : 'Unknown');

    // Extract flight information from our template structure
    const flights = extractFlightsFromPdfMonkeyTemplate(content);

    // Extract hotel information (only for combined template)
    const hotels = isCombinedTemplate ? extractHotelsFromPdfMonkeyTemplate(content) : [];

    // Extract total price
    const totalPrice = extractTotalPriceFromPdfMonkeyTemplate(content);

    // Extract passenger information
    const passengers = extractPassengersFromPdfMonkeyTemplate(content);

    // Extract currency
    const currency = extractCurrencyFromPdfMonkeyTemplate(content);

    // Determine original template ID based on content
    const originalTemplate = isCombinedTemplate ?
        "3E8394AC-84D4-4286-A1CD-A12D1AB001D5" : // COMBINED_TEMPLATE_ID
        "67B7F3A5-7BFE-4F52-BE6B-110371CB9376";   // FLIGHT_TEMPLATE_ID

    return {
        success: true,
        content: {
            flights,
            hotels,
            totalPrice,
            currency,
            passengers,
            // Additional metadata for regeneration
            originalTemplate,
            extractedFromPdfMonkey: true
        },
        suggestions: [
            "Como este PDF fue generado por nuestro sistema, puedo regenerarlo con cualquier precio que especifiques",
            "Mantendr√© todos los detalles originales: vuelos, hoteles, fechas, pasajeros",
            "Solo cambiar√© los precios seg√∫n tu solicitud",
            "El nuevo PDF tendr√° la misma calidad y formato profesional"
        ]
    };
}

/**
 * Analyze PDF content using AI or structured extraction
 */
export async function analyzePdfContent(file: File): Promise<PdfAnalysisResult> {
    try {
        console.log('üìÑ Analyzing PDF:', file.name);

        // Always extract text content first to determine if it's our template
        console.log('üìã Extracting PDF content for analysis');

        // Convert file to array buffer for PDF processing
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);

        // Extract text content from PDF using Supabase Edge Function
        const { data: extractionResult, error } = await supabase.functions.invoke('pdf-text-extractor', {
            body: {
                pdfData: Array.from(uint8Array),
                fileName: file.name
            }
        });

        if (error) {
            console.error('‚ùå PDF extraction error:', error);
            throw new Error(`PDF extraction failed: ${error.message}`);
        }

        if (!extractionResult?.success) {
            throw new Error(extractionResult?.error || 'PDF extraction failed');
        }

        const extractedText = extractionResult.text;
        console.log('üìÑ Extracted PDF text:', extractedText.substring(0, 500) + '...');

        // Check if this is a PDF generated by our PdfMonkey template using both filename and content
        if (isPdfMonkeyTemplate(file.name, extractedText)) {
            console.log('üéØ PDF recognized as PdfMonkey template - using structured extraction');

            return extractPdfMonkeyDataFromContent(file.name, extractedText);
        }

        // For external PDFs, parse the extracted content
        console.log('üìã External PDF detected - parsing extracted content');

        // Parse extracted text to find travel information
        const parsedData = parseExtractedTravelData(extractedText);

        return {
            success: true,
            content: parsedData,
            suggestions: [
                "Puedo buscar vuelos con mejores horarios o conexiones m√°s cortas",
                "Hay hoteles con mejor ubicaci√≥n disponibles en las mismas fechas",
                "Podr√≠a encontrar opciones m√°s econ√≥micas con fechas flexibles",
                "¬øTe interesa agregar servicios adicionales como traslados o seguro de viaje?"
            ]
        };

    } catch (error) {
        console.error('Error analyzing PDF:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Error analyzing PDF content'
        };
    }
}

/**
 * Generate price change suggestions based on PDF content
 */
export function generatePriceChangeSuggestions(analysis: PdfAnalysisResult): string {
    if (!analysis.success || !analysis.content) {
        return generateManualDataEntryPrompt();
    }

    const { content, suggestions } = analysis;

    // Check if we have meaningful data extracted
    const hasValidData = (content.flights && content.flights.length > 0 && content.flights[0].price > 0) ||
        (content.hotels && content.hotels.length > 0 && content.hotels[0].price > 0) ||
        (content.totalPrice && content.totalPrice > 0);

    if (!hasValidData) {
        return generateManualDataEntryPrompt();
    }

    let response = `üìÑ **An√°lisis de tu Cotizaci√≥n**\n\n`;

    // Flight information
    if (content.flights && content.flights.length > 0) {
        response += `‚úàÔ∏è **Vuelos Encontrados:**\n\n`;
        content.flights.forEach((flight, index) => {
            response += `${flight.airline} - ${flight.route}\n`;
            response += `üìÖ ${flight.dates} | üí∞ $${flight.price} ${content.currency}\n\n`;
        });
    }

    // Hotel information
    if (content.hotels && content.hotels.length > 0) {
        response += `üè® **Hoteles Encontrados:**\n\n`;
        content.hotels.forEach((hotel, index) => {
            response += `${hotel.name} - ${hotel.location}\n`;
            response += `üåô ${hotel.nights} noches | üí∞ $${hotel.price}/noche\n\n`;
        });
    }

    // Total price
    if (content.totalPrice) {
        response += `üí∞ **Precio Total:** $${content.totalPrice} ${content.currency || 'USD'}\n`;
        response += `üë• **Pasajeros:** ${content.passengers || 1}\n\n`;
    }

    // Suggestions
    if (suggestions && suggestions.length > 0) {
        response += `üîÑ **Sugerencias de Mejora:**\n\n`;
        suggestions.forEach((suggestion, index) => {
            response += `${suggestion}\n\n`;
        });

        // Add cheaper flights option if there are flights in the PDF
        if (content.flights && content.flights.length > 0) {
            response += `üí° **Opciones adicionales:**\n\n`;
            response += `‚Ä¢ Escribe "buscar vuelos m√°s baratos" para encontrar alternativas m√°s econ√≥micas\n`;
            response += `‚Ä¢ Escribe "cambiar precio a $[cantidad]" para modificar el presupuesto\n\n`;
        }
    }

    response += `üí¨ **¬øQu√© te gustar√≠a modificar?**\n\n`;
    response += `Puedes pedirme:\n\n`;
    response += `‚Ä¢ "Busca vuelos m√°s baratos para las mismas fechas"\n\n`;
    response += `‚Ä¢ "Encuentra hoteles de 4 estrellas en vez de 5"\n\n`;
    response += `‚Ä¢ "Cambia las fechas a la segunda quincena de noviembre"\n\n`;
    response += `‚Ä¢ "Agrega seguro de viaje y traslados"\n\n`;

    return response;
}

/**
 * Generate manual data entry prompt when PDF analysis fails
 */
function generateManualDataEntryPrompt(): string {
    return `üìÑ **PDF Analizado - Datos Manuales Requeridos**\n\n` +
        `He analizado tu PDF pero no pude extraer autom√°ticamente los datos estructurados (el PDF est√° comprimido). Sin embargo, puedo ayudarte de varias maneras:\n\n` +
        `üí∞ **Para cambiar precios:**\n` +
        `‚Ä¢ Dime el precio total actual y el nuevo precio que quieres\n` +
        `‚Ä¢ Ejemplo: "El PDF tiene un total de $1200, quiero cambiarlo a $1000"\n` +
        `‚Ä¢ Ejemplo: "Cambiar precio a $800"\n\n` +
        `üìã **Para an√°lisis completo:**\n` +
        `‚Ä¢ Comparte los detalles principales: origen, destino, fechas, pasajeros\n` +
        `‚Ä¢ Ejemplo: "Vuelo EZE-MAD del 15/11 al 22/11 para 2 personas, precio $1200"\n\n` +
        `üîÑ **Opciones disponibles:**\n` +
        `‚Ä¢ "Cambiar precio a $[cantidad]" - Genero un nuevo PDF profesional con ese precio\n` +
        `‚Ä¢ "Buscar alternativas m√°s baratas" - Busco opciones similares\n` +
        `‚Ä¢ "Regenerar PDF con precio $[cantidad]" - Creo un PDF completamente nuevo\n\n` +
        `üí° **¬øQu√© informaci√≥n tienes del PDF o qu√© precio quieres?**`;
}

/**
 * Extract price from user message
 */
function extractPriceFromMessage(message: string): number | null {
    // Look for patterns like: $1200, 1200 USD, 1200 d√≥lares, etc.
    const pricePatterns = [
        /\$\s*(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/g,
        /(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)\s*(?:USD|usd|d√≥lares?|dolares?)/gi,
        /precio.*?(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/gi,
        /total.*?(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/gi,
        /cambia.*?(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/gi,
        /por\s+(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/gi
    ];

    // First try to find numbers with context (more specific patterns)
    for (const pattern of pricePatterns) {
        const matches = message.match(pattern);
        if (matches) {
            for (const match of matches) {
                const numberMatch = match.match(/(\d{1,6}(?:,\d{3})*(?:\.\d{2})?)/);
                if (numberMatch) {
                    const price = parseFloat(numberMatch[1].replace(/,/g, ''));
                    if (price > 0 && price < 100000) { // Reasonable price range
                        console.log('üí∞ [PRICE EXTRACTION] Found price with context:', price, 'from match:', match);
                        return price;
                    }
                }
            }
        }
    }

    // If no contextual match, look for standalone numbers (but be more careful)
    const standaloneNumbers = message.match(/\b(\d{3,6})\b/g);
    if (standaloneNumbers) {
        // Filter out common non-price numbers
        const filteredNumbers = standaloneNumbers.filter(num => {
            const value = parseInt(num);
            return value >= 100 && value <= 50000; // Reasonable price range
        });

        if (filteredNumbers.length > 0) {
            // Take the largest number found (most likely to be the price)
            const maxPrice = Math.max(...filteredNumbers.map(n => parseInt(n)));
            console.log('üí∞ [PRICE EXTRACTION] Found standalone number:', maxPrice);
            return maxPrice;
        }
    }

    console.log('üí∞ [PRICE EXTRACTION] No price found in message:', message);
    return null;
}

/**
 * Reconstruct FlightData from extracted PDF data
 */
function reconstructFlightData(analysis: PdfAnalysisResult, newPrice: number): any[] {
    if (!analysis.content?.flights) return [];

    const originalPrice = analysis.content.totalPrice || 0;
    const priceRatio = originalPrice > 0 ? newPrice / originalPrice : 1;

    return analysis.content.flights.map((flight, index) => {
        // Parse dates from PDF data
        const datesParsed = parseDateRange(flight.dates);

        // Extract route information from PDF
        const routeInfo = parseFlightRoute(flight.route);

        // Get airline code from PDF data or extract from airline name
        const airlineCode = extractAirlineCode(flight.airline);

        // Build legs from extracted PDF data
        const legs = [];

        // Check if flight has detailed leg information from enhanced extraction
        if ((flight as any).legs && (flight as any).legs.length > 0) {
            // Use detailed leg information from PDF
            const pdfLegs = (flight as any).legs;

            // Add outbound legs
            pdfLegs.forEach((leg: any, legIndex: number) => {
                if (legIndex < pdfLegs.length / 2 || pdfLegs.length <= 2) {
                    legs.push({
                        departure: {
                            city_code: leg.from || routeInfo.origin,
                            city_name: mapCodeToCity(leg.from || routeInfo.origin),
                            time: leg.departureTime || (flight as any).departureTime || '08:00'
                        },
                        arrival: {
                            city_code: leg.to || routeInfo.destination,
                            city_name: mapCodeToCity(leg.to || routeInfo.destination),
                            time: leg.arrivalTime || (flight as any).arrivalTime || '18:00'
                        },
                        duration: calculateFlightDuration(leg.departureTime, leg.arrivalTime) || '10h',
                        flight_type: 'outbound',
                        flight_number: leg.flightNumber
                    });
                }
            });

            // Add return legs for round trip
            if (datesParsed.returnDate) {
                pdfLegs.forEach((leg: any, legIndex: number) => {
                    if (legIndex >= pdfLegs.length / 2 && pdfLegs.length > 2) {
                        legs.push({
                            departure: {
                                city_code: leg.from || routeInfo.destination,
                                city_name: mapCodeToCity(leg.from || routeInfo.destination),
                                time: leg.departureTime || '10:00'
                            },
                            arrival: {
                                city_code: leg.to || routeInfo.origin,
                                city_name: mapCodeToCity(leg.to || routeInfo.origin),
                                time: leg.arrivalTime || '20:00'
                            },
                            duration: calculateFlightDuration(leg.departureTime, leg.arrivalTime) || '10h',
                            flight_type: 'return',
                            flight_number: leg.flightNumber
                        });
                    }
                });

                // If no return legs found but we have a return date, create return legs
                const returnLegsExist = legs.some(leg => leg.flight_type === 'return');
                if (!returnLegsExist && routeInfo.origin && routeInfo.destination) {
                    legs.push({
                        departure: {
                            city_code: routeInfo.destination,
                            city_name: mapCodeToCity(routeInfo.destination),
                            time: (flight as any).departureTime || '10:00'
                        },
                        arrival: {
                            city_code: routeInfo.origin,
                            city_name: mapCodeToCity(routeInfo.origin),
                            time: (flight as any).arrivalTime || '20:00'
                        },
                        duration: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h',
                        flight_type: 'return'
                    });
                }
            }
        } else {
            // Fallback: create basic legs from route information
            if (routeInfo.origin && routeInfo.destination) {
                // Outbound leg
                legs.push({
                    departure: {
                        city_code: routeInfo.origin,
                        city_name: mapCodeToCity(routeInfo.origin),
                        time: (flight as any).departureTime || '08:00'
                    },
                    arrival: {
                        city_code: routeInfo.destination,
                        city_name: mapCodeToCity(routeInfo.destination),
                        time: (flight as any).arrivalTime || '18:00'
                    },
                    duration: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h',
                    flight_type: 'outbound'
                });

                // Return leg if round trip
                if (datesParsed.returnDate) {
                    legs.push({
                        departure: {
                            city_code: routeInfo.destination,
                            city_name: mapCodeToCity(routeInfo.destination),
                            time: (flight as any).departureTime || '10:00'
                        },
                        arrival: {
                            city_code: routeInfo.origin,
                            city_name: mapCodeToCity(routeInfo.origin),
                            time: (flight as any).arrivalTime || '20:00'
                        },
                        duration: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h',
                        flight_type: 'return'
                    });
                }
            }
        }

        // Generate realistic flight data
        const flightPrice = Math.round(flight.price * priceRatio);
        const isRealisticData = flight.airline !== 'Aerol√≠nea' && flight.route !== 'Origen - Destino';

        return {
            id: `regenerated-${Date.now()}-${index}`,
            airline: {
                code: airlineCode,
                name: isRealisticData ? flight.airline : 'Aerol√≠nea Principal'
            },
            price: {
                amount: flightPrice,
                currency: analysis.content?.currency || 'USD',
                breakdown: {
                    fareAmount: Math.round(flightPrice * 0.75),
                    taxAmount: Math.round(flightPrice * 0.25),
                    serviceAmount: 0,
                    commissionAmount: 0
                }
            },
            adults: analysis.content?.passengers || 1,
            childrens: 0,
            departure_date: isRealisticData ? datesParsed.departureDate : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
            return_date: isRealisticData ? datesParsed.returnDate : new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
            departure_time: (flight as any).departureTime || '08:00',
            arrival_time: (flight as any).arrivalTime || '18:00',
            duration: { formatted: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h' },
            stops: { direct: legs.length <= 2, count: Math.max(0, legs.length - 2) },
            baggage: { included: true, details: '2PC' },
            cabin: { class: 'Economy', brandName: 'Economy Flexible' },
            booking: {
                lastTicketingDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                validatingCarrier: airlineCode,
                fareType: 'P'
            },
            legs: legs.length > 0 ? legs : [{
                departure: {
                    city_code: 'EZE',
                    city_name: 'Buenos Aires',
                    time: '08:00'
                },
                arrival: {
                    city_code: 'MAD',
                    city_name: 'Madrid',
                    time: '18:00'
                },
                duration: '10h',
                flight_type: 'outbound'
            }]
        };
    });
}

/**
 * Reconstruct HotelData from extracted PDF data  
 */
function reconstructHotelData(analysis: PdfAnalysisResult, newPrice: number): any[] {
    if (!analysis.content?.hotels) return [];

    const originalPrice = analysis.content.totalPrice || 0;
    const priceRatio = originalPrice > 0 ? newPrice / originalPrice : 1;

    return analysis.content.hotels.map((hotel, index) => {
        const adjustedNightlyPrice = Math.round((hotel.price * priceRatio));
        const adjustedTotalPrice = adjustedNightlyPrice * hotel.nights;

        return {
            id: `regenerated-hotel-${Date.now()}-${index}`,
            name: hotel.name,
            city: hotel.location,
            address: hotel.location,
            category: "4",
            nights: hotel.nights,
            check_in: analysis.content?.flights?.[0]?.dates.split(' / ')[0] || '2025-11-01',
            check_out: analysis.content?.flights?.[0]?.dates.split(' / ')[1] || '2025-11-15',
            rooms: [{
                type: 'Standard',
                description: 'Habitaci√≥n est√°ndar',
                price_per_night: adjustedNightlyPrice,
                total_price: adjustedTotalPrice,
                currency: analysis.content?.currency || 'USD',
                availability: 5,
                occupancy_id: `room-${index}-modified`
            }]
        };
    });
}

/**
 * Generate modified PDF with new price
 */
export async function generateModifiedPdf(
    analysis: PdfAnalysisResult,
    newPrice: number,
    conversationId: string
): Promise<{ success: boolean; pdfUrl?: string; error?: string }> {
    try {
        console.log('üîÑ Generating modified PDF with new price:', newPrice);
        console.log('üéØ PDF source:', analysis.content?.extractedFromPdfMonkey ? 'PdfMonkey Template' : 'External PDF');

        // Import the PDF generation service
        const { generateCombinedTravelPdf } = await import('./pdfMonkey');

        if (!analysis.content) {
            throw new Error('No content available from PDF analysis');
        }

        // Calculate price adjustment details
        const originalPrice = analysis.content.totalPrice || 0;
        const priceAdjustment = newPrice - originalPrice;
        const adjustmentPercentage = originalPrice > 0 ? (priceAdjustment / originalPrice) * 100 : 0;

        console.log('üìä Price adjustment details:', {
            originalPrice,
            newPrice,
            adjustment: priceAdjustment,
            percentage: adjustmentPercentage.toFixed(2) + '%',
            isPdfMonkeyTemplate: analysis.content.extractedFromPdfMonkey
        });

        let adjustedFlights: any[];
        let adjustedHotels: any[];

        if (analysis.content.extractedFromPdfMonkey) {
            // For our own PDFs, reconstruct the data more accurately
            console.log('üèóÔ∏è Reconstructing data from PdfMonkey template');
            adjustedFlights = reconstructFlightData(analysis, newPrice);
            adjustedHotels = reconstructHotelData(analysis, newPrice);
        } else {
            // For external PDFs, use the previous approach
            console.log('üîÑ Adapting external PDF data');
            const priceRatio = originalPrice > 0 ? newPrice / originalPrice : 1;

            adjustedFlights = analysis.content.flights?.map((flight, index) => {
                const datesParsed = parseDateRange(flight.dates);
                const routeInfo = parseFlightRoute(flight.route);
                const airlineCode = extractAirlineCode(flight.airline);

                const legs = [];

                // Outbound leg using real data
                if (routeInfo.origin && routeInfo.destination) {
                    legs.push({
                        departure: {
                            city_code: routeInfo.origin,
                            city_name: mapCodeToCity(routeInfo.origin),
                            time: (flight as any).departureTime || '08:00'
                        },
                        arrival: {
                            city_code: routeInfo.destination,
                            city_name: mapCodeToCity(routeInfo.destination),
                            time: (flight as any).arrivalTime || '18:00'
                        },
                        duration: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h',
                        flight_type: 'outbound'
                    });

                    // Return leg if round trip
                    if (datesParsed.returnDate) {
                        legs.push({
                            departure: {
                                city_code: routeInfo.destination,
                                city_name: mapCodeToCity(routeInfo.destination),
                                time: (flight as any).departureTime || '10:00'
                            },
                            arrival: {
                                city_code: routeInfo.origin,
                                city_name: mapCodeToCity(routeInfo.origin),
                                time: (flight as any).arrivalTime || '20:00'
                            },
                            duration: calculateFlightDuration((flight as any).departureTime, (flight as any).arrivalTime) || '10h',
                            flight_type: 'return'
                        });
                    }
                }

                return {
                    id: `external-modified-${Date.now()}-${index}`,
                    airline: { code: airlineCode, name: flight.airline },
                    price: {
                        amount: Math.round(flight.price * priceRatio),
                        currency: analysis.content?.currency || 'USD'
                    },
                    adults: analysis.content?.passengers || 1,
                    childrens: 0,
                    departure_date: datesParsed.departureDate,
                    return_date: datesParsed.returnDate,
                    legs: legs
                };
            }) || [];

            adjustedHotels = analysis.content.hotels?.map((hotel, index) => ({
                id: `external-modified-hotel-${Date.now()}-${index}`,
                name: hotel.name,
                city: hotel.location,
                address: hotel.location,
                check_in: analysis.content?.flights?.[0]?.dates.split(' / ')[0] || '2025-11-01',
                check_out: analysis.content?.flights?.[0]?.dates.split(' / ')[1] || '2025-11-15',
                rooms: [{
                    type: 'Standard',
                    description: 'Habitaci√≥n est√°ndar modificada',
                    total_price: Math.round(hotel.price * hotel.nights * priceRatio),
                    currency: analysis.content?.currency || 'USD',
                    availability: 5,
                    occupancy_id: `external-room-${index}`
                }]
            })) || [];
        }

        // Ensure exact total equals the requested newPrice by applying a final delta adjustment
        const currentFlightsTotal = adjustedFlights.reduce((sum, f) => sum + (f.price?.amount || 0), 0);
        const currentHotelsTotal = adjustedHotels.reduce((sum, h) => sum + (h.rooms?.[0]?.total_price || 0), 0);
        const currentTotal = currentFlightsTotal + currentHotelsTotal;
        const deltaToTarget = Math.round(newPrice - currentTotal);

        if (deltaToTarget !== 0) {
            // Prefer adjusting hotels (room total) to keep flight fares intact; otherwise adjust last flight amount
            if (adjustedHotels.length > 0 && adjustedHotels[adjustedHotels.length - 1]?.rooms?.[0]) {
                const lastHotel = adjustedHotels[adjustedHotels.length - 1];
                const room = lastHotel.rooms[0];
                const newTotalPrice = Math.max(0, (room.total_price || 0) + deltaToTarget);
                room.total_price = newTotalPrice;
            } else if (adjustedFlights.length > 0) {
                const lastFlight = adjustedFlights[adjustedFlights.length - 1];
                const newAmount = Math.max(0, (lastFlight.price?.amount || 0) + deltaToTarget);
                lastFlight.price = {
                    ...(lastFlight.price || {}),
                    amount: newAmount,
                    currency: analysis.content?.currency || 'USD'
                };
            }
        }

        console.log('üìã Regenerating PDF with adjusted data:', {
            flights: adjustedFlights.length,
            hotels: adjustedHotels.length,
            totalFlightPrice: adjustedFlights.reduce((sum, f) => sum + (f.price?.amount || 0), 0),
            totalHotelPrice: adjustedHotels.reduce((sum, h) => sum + (h.rooms?.[0]?.total_price || 0), 0),
            targetTotal: newPrice
        });

        // Generate the modified PDF using our existing PdfMonkey service
        console.log('üìÑ Generating PDF with:', {
            flights: adjustedFlights.length,
            hotels: adjustedHotels.length,
            totalPrice: newPrice
        });

        const pdfResult = await generateCombinedTravelPdf(adjustedFlights, adjustedHotels);

        if (pdfResult.success && pdfResult.document_url) {
            console.log('‚úÖ Modified PDF generated successfully:', pdfResult.document_url);
            return {
                success: true,
                pdfUrl: pdfResult.document_url
            };
        } else {
            throw new Error(pdfResult.error || 'Failed to generate PDF');
        }

    } catch (error) {
        console.error('‚ùå Error generating modified PDF:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
        };
    }
}

/**
 * Process price change request based on PDF analysis
 */
export async function processPriceChangeRequest(
    request: string,
    analysis: PdfAnalysisResult,
    conversationId: string
): Promise<{ response: string; modifiedPdfUrl?: string }> {
    try {
        console.log('üîÑ Processing price change request:', request);
        console.log('üìä Analysis data:', analysis);

        const lowerRequest = request.toLowerCase();

        // Check if user is specifying a specific price
        const requestedPrice = extractPriceFromMessage(request);

        if (requestedPrice) {
            console.log('üí∞ User requested specific price:', requestedPrice);

            // If we have analysis data, use it; otherwise create a basic analysis
            let effectiveAnalysis = analysis;

            if (!analysis.success || !analysis.content || !analysis.content.totalPrice) {
                console.log('üìã Creating basic analysis from request...');

                // Try to extract some basic info from the original request if available
                const lowerRequest = request.toLowerCase();
                const hasFlight = lowerRequest.includes('vuelo') || lowerRequest.includes('flight');
                const hasHotel = lowerRequest.includes('hotel') || lowerRequest.includes('alojamiento');
                const isCombined = hasFlight && hasHotel;

                // Create realistic flight data
                const flights = [{
                    airline: 'Aerol√≠nea',
                    route: 'Origen - Destino',
                    price: isCombined ? Math.round(requestedPrice * 0.7) : requestedPrice,
                    dates: 'Fecha de viaje'
                }];

                // Create hotel data if it's a combined request
                const hotels = isCombined ? [{
                    name: 'Hotel Recomendado',
                    location: 'Destino',
                    price: Math.round(requestedPrice * 0.3 / 7), // Assume 7 nights
                    nights: 7
                }] : [];

                effectiveAnalysis = {
                    success: true,
                    content: {
                        totalPrice: requestedPrice,
                        currency: 'USD',
                        passengers: 1,
                        flights,
                        hotels,
                        extractedFromPdfMonkey: false
                    }
                };
            }

            // Generate modified PDF with the new price
            const pdfResult = await generateModifiedPdf(effectiveAnalysis, requestedPrice, conversationId);

            if (pdfResult.success && pdfResult.pdfUrl) {
                const originalPrice = effectiveAnalysis.content?.totalPrice || 0;
                const difference = requestedPrice - originalPrice;
                const isIncrease = difference > 0;

                const isPdfMonkeyTemplate = effectiveAnalysis.content?.extractedFromPdfMonkey;

                const response = `üí∞ **Precio Modificado Exitosamente**\n\n` +
                    `üìÑ He ${isPdfMonkeyTemplate ? 'regenerado' : 'generado'} un nuevo PDF con tu precio solicitado:\n\n` +
                    `‚Ä¢ **Precio solicitado:** $${requestedPrice.toLocaleString()} ${effectiveAnalysis.content?.currency || 'USD'}\n` +
                    `‚Ä¢ **Pasajeros:** ${effectiveAnalysis.content?.passengers || 1}\n\n` +
                    `${isPdfMonkeyTemplate ?
                        'üéØ **PDF Regenerado con Nuestro Sistema**\n\n‚Ä¢ Utilic√© el mismo template profesional que usamos para generar cotizaciones\n‚Ä¢ Mantuve todos los detalles exactos: vuelos, hoteles, fechas y pasajeros\n‚Ä¢ Solo ajust√© los precios seg√∫n tu solicitud\n‚Ä¢ La calidad y formato son id√©nticos al original' :
                        '‚úÖ **PDF Generado Exitosamente**\n\n‚Ä¢ Cre√© un PDF profesional con el precio que solicitaste\n‚Ä¢ Incluye todos los detalles de viaje necesarios\n‚Ä¢ Formato limpio y profesional'
                    }\n\nüìÑ **PDF listo para descargar**`;

                return {
                    response,
                    modifiedPdfUrl: pdfResult.pdfUrl
                };
            } else {
                return {
                    response: `‚ùå **Error generando PDF modificado**\n\nNo pude generar el PDF con el nuevo precio de $${requestedPrice}. Error: ${pdfResult.error}\n\n¬øPodr√≠as intentar nuevamente?`
                };
            }
        }

        // Handle other types of requests (existing functionality)
        if (lowerRequest.includes('m√°s barato') || lowerRequest.includes('menor precio')) {
            return {
                response: `üîç **Buscando opciones m√°s econ√≥micas...**\n\nHe encontrado las siguientes alternativas:\n\n‚úàÔ∏è **Vuelos m√°s baratos:**\n‚Ä¢ Copa Airlines: EZE ‚Üí PTY ‚Üí PUJ - $645 USD (ahorro: $80)\n‚Ä¢ JetBlue: EZE ‚Üí FLL ‚Üí PUJ - $689 USD (ahorro: $36)\n\nüè® **Hoteles m√°s econ√≥micos:**\n‚Ä¢ Hotel Marien Puerto Playa: $32/noche (ahorro: $13/noche)\n‚Ä¢ Casa Colonial Beach & Spa: $38/noche (ahorro: $7/noche)\n\nüí∞ **Nuevo total estimado:** $1,180 USD (ahorro: $175)\n\n¬øTe interesan estas opciones? O si tienes un precio espec√≠fico en mente, d√≠melo y genero un PDF con ese precio exacto.`
            };
        }

        if (lowerRequest.includes('fecha') || lowerRequest.includes('cambiar')) {
            return {
                response: `üìÖ **Opciones con fechas flexibles:**\n\nSi cambias las fechas, puedo conseguir mejores precios:\n\n‚Ä¢ **Noviembre 8-22:** $1,245 USD (ahorro: $110)\n‚Ä¢ **Noviembre 15-29:** $1,189 USD (ahorro: $166)\n‚Ä¢ **Diciembre 1-15:** $1,425 USD (+$70)\n\n¬øCu√°les fechas prefieres? O si tienes un precio objetivo, puedo generar un PDF con ese precio espec√≠fico.`
            };
        }

        if (lowerRequest.includes('hotel') && lowerRequest.includes('estrella')) {
            return {
                response: `‚≠ê **Opciones de hoteles por categor√≠a:**\n\nüè® **4 Estrellas:**\n‚Ä¢ Iberostar Selection B√°varo: $55/noche\n‚Ä¢ Dreams Macao Beach: $48/noche\n\nüè® **3 Estrellas:**\n‚Ä¢ Tropical Princess Beach: $35/noche\n‚Ä¢ Be Live Collection Marien: $42/noche\n\n¬øQu√© categor√≠a prefieres? Tambi√©n puedes decirme un precio espec√≠fico y genero un PDF con ese monto.`
            };
        }

        // Default response with price modification hint
        return {
            response: `ü§î **Entendido tu solicitud**\n\nPuedo ayudarte de varias maneras:\n\nüí∞ **Cambio de precio espec√≠fico:**\n‚Ä¢ Dime: "Cambia el precio total a $1200" o "Quiero que cueste $800"\n‚Ä¢ Generar√© un nuevo PDF con el precio exacto que solicites\n\nüîç **B√∫squeda de alternativas:**\n‚Ä¢ ¬øQu√© aspecto quieres cambiar? (vuelos, hoteles, fechas)\n‚Ä¢ ¬øTienes un presupuesto espec√≠fico en mente?\n‚Ä¢ ¬øLas fechas son flexibles?\n\n**Ejemplo:** "Cambia el precio total a $1100 USD" y te genero el PDF modificado inmediatamente.`
        };

    } catch (error) {
        console.error('Error processing price change request:', error);
        return {
            response: `‚ùå Hubo un error procesando tu solicitud. ¬øPodr√≠as intentarlo nuevamente con m√°s detalles?`
        };
    }
}

/**
 * Search for cheaper flight alternatives based on PDF analysis
 */
export async function searchCheaperFlights(pdfAnalysis: PdfAnalysisResult): Promise<CheaperFlightSearchResult> {
    try {
        console.log('üîç Starting cheaper flight search from PDF analysis');

        if (!pdfAnalysis.success || !pdfAnalysis.content?.flights) {
            return {
                success: false,
                error: 'No flight information found in PDF analysis'
            };
        }

        const originalFlights = pdfAnalysis.content.flights;
        console.log('‚úàÔ∏è Original flights from PDF:', originalFlights);

        // Extract search parameters from the first flight
        const firstFlight = originalFlights[0];
        if (!firstFlight) {
            return {
                success: false,
                error: 'No flight data available'
            };
        }

        // Parse route to get origin and destination
        const { origin, destination } = parseFlightRoute(firstFlight.route);
        if (!origin || !destination) {
            return {
                success: false,
                error: 'Could not parse flight route from PDF'
            };
        }

        // Parse dates (assuming format from PDF)
        const dateRange = firstFlight.dates;
        const dates = dateRange.split(' - ');
        const departureDate = parseDate(dates[0]);
        const returnDate = dates.length > 1 ? parseDate(dates[1]) : undefined;

        const searchParams: AirfareSearchParams = {
            origin,
            destination,
            departureDate,
            returnDate,
            adults: pdfAnalysis.content.passengers || 1,
            children: 0
        };

        console.log('üîç Searching with parameters:', searchParams);

        // Convert to Starling format for flight search
        const starlingRequest = formatParsedDataForStarling({
            requestType: 'flights',
            flights: {
                origin,
                destination,
                departureDate,
                returnDate,
                adults: searchParams.adults || 1,
                children: searchParams.children || 0
            }
        } as any);

        console.log('üîç Starling request format:', starlingRequest);

        // Search for alternative flights using Starling API
        const alternativeFlights = await searchFlightsWithStarling(starlingRequest);

        if (alternativeFlights.length === 0) {
            return {
                success: true,
                originalFlights,
                alternativeFlights: [],
                message: 'No se encontraron vuelos alternativos para estas fechas y destino.'
            };
        }

        // Calculate potential savings
        const originalTotalPrice = originalFlights.reduce((sum, flight) => sum + flight.price, 0);
        const cheapestAlternative = alternativeFlights.reduce((cheapest, current) =>
            (current.price?.amount || 0) < (cheapest.price?.amount || 0) ? current : cheapest
        );

        const potentialSavings = originalTotalPrice - (cheapestAlternative.price?.amount || 0);

        console.log('üí∞ Price comparison:', {
            original: originalTotalPrice,
            cheapest: cheapestAlternative.price?.amount,
            savings: potentialSavings
        });

        return {
            success: true,
            originalFlights,
            alternativeFlights,
            savings: potentialSavings > 0 ? potentialSavings : 0,
            message: potentialSavings > 0
                ? `¬°Encontr√© opciones m√°s baratas! Puedes ahorrar hasta $${potentialSavings.toFixed(2)} USD`
                : 'Los precios del PDF son competitivos, pero aqu√≠ tienes m√°s opciones disponibles.'
        };

    } catch (error) {
        console.error('‚ùå Error searching for cheaper flights:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Error searching for alternative flights'
        };
    }
}

/**
 * Helper function to parse date from PDF text
 */
function parseDate(dateStr: string): string {
    try {
        // Handle different date formats from PDF
        dateStr = dateStr.trim();

        // If already in YYYY-MM-DD format
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            return dateStr;
        }

        // Handle DD/MM/YYYY format
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
            const [day, month, year] = dateStr.split('/');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        }

        // Handle DD-MM-YYYY format
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateStr)) {
            const [day, month, year] = dateStr.split('-');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        }

        // Handle text dates like "15 Nov 2024"
        const months = {
            'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
            'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
            'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12',
            'enero': '01', 'febrero': '02', 'marzo': '03', 'abril': '04',
            'mayo': '05', 'junio': '06', 'julio': '07', 'agosto': '08',
            'septiembre': '09', 'octubre': '10', 'noviembre': '11', 'diciembre': '12'
        };

        const dateMatch = dateStr.match(/(\d{1,2})\s+(\w+)\s+(\d{4})/i);
        if (dateMatch) {
            const [, day, monthName, year] = dateMatch;
            const monthNum = months[monthName.toLowerCase().substring(0, 3)];
            if (monthNum) {
                return `${year}-${monthNum}-${day.padStart(2, '0')}`;
            }
        }

        // Fallback: use current date + 7 days
        const fallbackDate = new Date();
        fallbackDate.setDate(fallbackDate.getDate() + 7);
        return fallbackDate.toISOString().split('T')[0];

    } catch (error) {
        console.warn('Could not parse date:', dateStr, error);
        // Return date 7 days from now as fallback
        const fallbackDate = new Date();
        fallbackDate.setDate(fallbackDate.getDate() + 7);
        return fallbackDate.toISOString().split('T')[0];
    }
}

/**
 * Parse extracted PDF text to find travel information
 */
function parseExtractedTravelData(text: string): PdfAnalysisResult['content'] {
    console.log('üîç Parsing extracted PDF text for travel data');
    console.log('üìÑ Full text to analyze:', text);

    const flights = extractFlightInfo(text);
    const hotels = extractHotelInfo(text);
    const totalPrice = extractTotalPrice(text);
    const passengers = extractPassengerCount(text);
    const currency = extractCurrency(text);

    console.log('üìä Extracted data summary:', {
        flights: flights.length,
        hotels: hotels.length,
        totalPrice,
        passengers,
        currency
    });

    return {
        flights,
        hotels,
        totalPrice,
        currency,
        passengers,
        extractedFromPdfMonkey: false
    };
}

/**
 * Extract flight information from PDF text with detailed parsing
 */
function extractFlightInfo(text: string): Array<{
    airline: string,
    route: string,
    price: number,
    dates: string,
    departureTime?: string,
    arrivalTime?: string,
    originCode?: string,
    destinationCode?: string,
    originCity?: string,
    destinationCity?: string,
    legs?: Array<{
        from: string,
        to: string,
        departureTime?: string,
        arrivalTime?: string,
        flightNumber?: string
    }>
}> {
    const flights: Array<{
        airline: string,
        route: string,
        price: number,
        dates: string,
        departureTime?: string,
        arrivalTime?: string,
        originCode?: string,
        destinationCode?: string,
        originCity?: string,
        destinationCity?: string,
        legs?: Array<{
            from: string,
            to: string,
            departureTime?: string,
            arrivalTime?: string,
            flightNumber?: string
        }>
    }> = [];

    // Enhanced patterns for detailed flight information
    const airlinePatterns = [
        /(?:LATAM|Aerol√≠neas Argentinas|American Airlines|United|Delta|Air France|Iberia|AVIANCA|JetSmart|Flybondi|Copa Airlines|LAN|TAM|Avianca|Iberia|Air France|British Airways|Lufthansa|KLM|Alitalia|Swiss|Austrian)/gi,
        /(?:AA|UA|DL|AF|IB|AV|LAN|TAM|CM|BA|LH|KL|AZ|LX|OS)/gi
    ];

    // Enhanced patterns for routes with more detail
    const routePatterns = [
        /([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})/g, // EZE - MIA
        /([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})\s*[-‚Äì‚Üí‚Üí‚Üí]\s*([A-Z]{3})/g, // EZE - MIA - PUJ
        /(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York|London|Paris|Rome|Amsterdam|Frankfurt|S√£o Paulo|R√≠o de Janeiro|Lima|Bogot√°|Santiago|M√©xico|Toronto|Montreal)\s*[-‚Äì‚Üí‚Üí‚Üí]\s*(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York|London|Paris|Rome|Amsterdam|Frankfurt|S√£o Paulo|R√≠o de Janeiro|Lima|Bogot√°|Santiago|M√©xico|Toronto|Montreal)/gi,

        // Airport code patterns with city names
        /(Ezeiza|Jorge Newbery|Aeroparque|Barajas|El Prat|Miami International|Punta Cana International|Canc√∫n International|John F\. Kennedy|LaGuardia|Newark|Heathrow|Gatwick|Charles de Gaulle|Orly|Fiumicino|Ciampino|Schiphol|Frankfurt|Zurich|Vienna|Guarulhos|Gale√£o|Jorge Ch√°vez|El Dorado|Arturo Merino Ben√≠tez|Benito Ju√°rez|Pearson|Trudeau)/gi
    ];

    // Enhanced patterns for dates
    const datePatterns = [
        /(\d{1,2})\/(\d{1,2})\/(\d{4})\s*[-‚Äì]\s*(\d{1,2})\/(\d{1,2})\/(\d{4})/g, // DD/MM/YYYY - DD/MM/YYYY
        /(\d{1,2})\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)\s+(\d{4})\s*[-‚Äì]\s*(\d{1,2})\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)\s+(\d{4})/gi,
        /(\d{4})-(\d{2})-(\d{2})\s*[-‚Äì]\s*(\d{4})-(\d{2})-(\d{2})/g // YYYY-MM-DD - YYYY-MM-DD
    ];

    // Patterns for flight times
    const timePatterns = [
        /(\d{1,2}):(\d{2})\s*[-‚Äì]\s*(\d{1,2}):(\d{2})/g, // 07:35 - 17:35
        /(?:salida|departure|dep).*?(\d{1,2}):(\d{2})/gi,
        /(?:llegada|arrival|arr).*?(\d{1,2}):(\d{2})/gi,
        /(\d{1,2}):(\d{2})\s*(?:AM|PM|am|pm)?/g // General time pattern
    ];

    // Patterns for flight numbers
    const flightNumberPatterns = [
        /(?:vuelo|flight|voo)\s*(?:n[o¬∫¬∞]?\.?\s*)?([A-Z]{2}\d{2,4})/gi,
        /([A-Z]{2}\s?\d{2,4})/g // AA 1234 or AA1234
    ];

    // Enhanced patterns for prices
    const pricePatterns = [
        /(?:USD|US\$|\$)\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/gi,
        /(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:USD|US\$|\$)/gi
    ];

    // Extract airlines
    const airlines = [];
    for (const pattern of airlinePatterns) {
        const matches = [...text.matchAll(pattern)];
        airlines.push(...matches.map(m => m[0]));
    }

    // Extract routes with detailed parsing
    const routes = [];
    const routeDetails = [];
    for (const pattern of routePatterns) {
        const matches = [...text.matchAll(pattern)];
        routes.push(...matches.map(m => m[0]));

        // Parse route details for origin/destination
        matches.forEach(match => {
            if (match.length >= 3) {
                // Route with connection: EZE - MIA - PUJ
                const origin = match[1];
                const destination = match[3] || match[2];
                const connection = match[3] ? match[2] : null;
                routeDetails.push({ origin, destination, connection, fullRoute: match[0] });
            } else if (match.length >= 2) {
                // Direct route: EZE - PUJ
                routeDetails.push({
                    origin: match[1],
                    destination: match[2],
                    connection: null,
                    fullRoute: match[0]
                });
            }
        });
    }

    // Extract dates
    const dates = [];
    for (const pattern of datePatterns) {
        const matches = [...text.matchAll(pattern)];
        dates.push(...matches.map(m => m[0]));
    }

    // Extract flight times
    const times = [];
    const departureTime = [];
    const arrivalTimes = [];
    for (const pattern of timePatterns) {
        const matches = [...text.matchAll(pattern)];
        times.push(...matches.map(m => m[0]));

        // Try to separate departure and arrival times
        matches.forEach(match => {
            if (match.length >= 4) {
                // Time range: 07:35 - 17:35
                departureTime.push(`${match[1]}:${match[2]}`);
                arrivalTimes.push(`${match[3]}:${match[4]}`);
            } else if (match.length >= 3) {
                // Single time
                times.push(`${match[1]}:${match[2]}`);
            }
        });
    }

    // Extract flight numbers
    const flightNumbers = [];
    for (const pattern of flightNumberPatterns) {
        const matches = [...text.matchAll(pattern)];
        flightNumbers.push(...matches.map(m => m[1] || m[0]));
    }

    // Extract prices
    const prices = [];
    for (const pattern of pricePatterns) {
        const matches = [...text.matchAll(pattern)];
        prices.push(...matches.map(m => {
            const priceStr = m[1] || m[0];
            return parseFloat(priceStr.replace(/,/g, ''));
        }));
    }

    // Combine extracted information with enhanced details
    const maxEntries = Math.max(airlines.length, routes.length, dates.length, prices.length, 1);

    for (let i = 0; i < maxEntries; i++) {
        const routeDetail = routeDetails[i];
        const flight = {
            airline: airlines[i] || 'Aerol√≠nea no especificada',
            route: routes[i] || 'Ruta no especificada',
            price: prices[i] || 0,
            dates: dates[i] || 'Fechas no especificadas',
            departureTime: departureTime[i],
            arrivalTime: arrivalTimes[i],
            originCode: routeDetail?.origin,
            destinationCode: routeDetail?.destination,
            originCity: mapCodeToCity(routeDetail?.origin || ''),
            destinationCity: mapCodeToCity(routeDetail?.destination || ''),
            legs: []
        };

        // Create legs based on route details
        if (routeDetail) {
            // Outbound leg
            flight.legs.push({
                from: routeDetail.origin,
                to: routeDetail.connection || routeDetail.destination,
                departureTime: departureTime[i * 2],
                arrivalTime: arrivalTimes[i * 2],
                flightNumber: flightNumbers[i * 2]
            });

            // If there's a connection, add second leg
            if (routeDetail.connection) {
                flight.legs.push({
                    from: routeDetail.connection,
                    to: routeDetail.destination,
                    departureTime: departureTime[i * 2 + 1],
                    arrivalTime: arrivalTimes[i * 2 + 1],
                    flightNumber: flightNumbers[i * 2 + 1]
                });
            }

            // For round trip, create return legs (reverse the outbound)
            if (dates[i] && dates[i].includes('-') || dates[i].includes('/')) {
                // Return leg (reverse)
                flight.legs.push({
                    from: routeDetail.destination,
                    to: routeDetail.connection || routeDetail.origin,
                    departureTime: departureTime[i * 2 + 2],
                    arrivalTime: arrivalTimes[i * 2 + 2],
                    flightNumber: flightNumbers[i * 2 + 2]
                });

                // If there was a connection on outbound, add connection on return
                if (routeDetail.connection) {
                    flight.legs.push({
                        from: routeDetail.connection,
                        to: routeDetail.origin,
                        departureTime: departureTime[i * 2 + 3],
                        arrivalTime: arrivalTimes[i * 2 + 3],
                        flightNumber: flightNumbers[i * 2 + 3]
                    });
                }
            }
        }

        flights.push(flight);
    }

    console.log('‚úàÔ∏è Extracted flights:', flights);
    return flights.slice(0, 3); // Limit to 3 flights max
}

/**
 * Extract hotel information from PDF text
 */
function extractHotelInfo(text: string): Array<{ name: string, location: string, price: number, nights: number }> {
    const hotels: Array<{ name: string, location: string, price: number, nights: number }> = [];

    // Patterns for hotel names
    const hotelPatterns = [
        /(?:Hotel|Resort|Aparthotel|Inn|Lodge|Suites?)\s+([A-Za-z\s]+)/gi,
        /([A-Za-z\s]+)\s+(?:Hotel|Resort|Aparthotel|Inn|Lodge|Suites?)/gi
    ];

    // Patterns for locations/cities
    const locationPatterns = [
        /(Punta Cana|Canc√∫n|Miami|Madrid|Barcelona|Buenos Aires|R√≠o de Janeiro|S√£o Paulo)/gi,
        /(?:en|in)\s+([A-Za-z\s]+)/gi
    ];

    // Patterns for nightly rates and nights
    const nightlyRatePatterns = [
        /(\d+)\s*(?:USD|US\$|\$)\s*(?:por noche|per night|\/night)/gi,
        /(?:por noche|per night|\/night)\s*(\d+)\s*(?:USD|US\$|\$)/gi
    ];

    const nightsPatterns = [
        /(\d+)\s*(?:noches?|nights?)/gi,
        /(?:noches?|nights?)\s*(\d+)/gi
    ];

    // Extract hotel names
    const hotelNames = [];
    for (const pattern of hotelPatterns) {
        const matches = [...text.matchAll(pattern)];
        hotelNames.push(...matches.map(m => m[1]?.trim()).filter(Boolean));
    }

    // Extract locations
    const locations = [];
    for (const pattern of locationPatterns) {
        const matches = [...text.matchAll(pattern)];
        locations.push(...matches.map(m => m[1]?.trim()).filter(Boolean));
    }

    // Extract nightly rates
    const nightlyRates = [];
    for (const pattern of nightlyRatePatterns) {
        const matches = [...text.matchAll(pattern)];
        nightlyRates.push(...matches.map(m => parseFloat(m[1])));
    }

    // Extract nights
    const nightsArray = [];
    for (const pattern of nightsPatterns) {
        const matches = [...text.matchAll(pattern)];
        nightsArray.push(...matches.map(m => parseInt(m[1])));
    }

    // Combine extracted information
    const maxEntries = Math.max(hotelNames.length, locations.length, nightlyRates.length, nightsArray.length, 1);

    for (let i = 0; i < maxEntries; i++) {
        hotels.push({
            name: hotelNames[i] || 'Hotel no especificado',
            location: locations[i] || 'Ubicaci√≥n no especificada',
            price: nightlyRates[i] || 0,
            nights: nightsArray[i] || 0
        });
    }

    console.log('üè® Extracted hotels:', hotels);
    return hotels.slice(0, 3); // Limit to 3 hotels max
}

/**
 * Extract total price from PDF text
 */
function extractTotalPrice(text: string): number {
    console.log('üí∞ Searching for total price in text...');

    // Enhanced patterns for total price extraction
    const totalPatterns = [
        // Spanish patterns
        /(?:total|precio total|total price|grand total|total general|precio final|monto total|importe total)\s*:?\s*(?:USD|US\$|\$)?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/gi,
        /(?:USD|US\$|\$)\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:total|precio total|total price|grand total)/gi,

        // Direct price patterns
        /\$\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:USD|usd)?/gi,
        /(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:USD|US\$|\$)/gi,

        // Price at end of line or paragraph
        /(?:precio|price|total|costo|cost)\s*:?\s*\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/gi,

        // Currency patterns
        /(?:USD|US\$|\$)\s*(\d{1,4}(?:,\d{3})*(?:\.\d{2})?)/gi
    ];

    let bestMatch = { price: 0, confidence: 0 };

    for (const pattern of totalPatterns) {
        const matches = [...text.matchAll(pattern)];
        console.log(`üí∞ Pattern "${pattern.source}" found ${matches.length} matches`);

        for (const match of matches) {
            const priceStr = match[1] || match[0];
            const price = parseFloat(priceStr.replace(/[^\d.]/g, ''));

            if (!isNaN(price) && price > 0 && price < 50000) { // Reasonable price range
                console.log(`üí∞ Found price: $${price} from match: "${match[0]}"`);

                // Higher confidence for "total" keywords
                const confidence = match[0].toLowerCase().includes('total') ? 2 : 1;

                if (confidence > bestMatch.confidence || (confidence === bestMatch.confidence && price > bestMatch.price)) {
                    bestMatch = { price, confidence };
                }
            }
        }
    }

    if (bestMatch.price > 0) {
        console.log('üí∞ Final extracted total price:', bestMatch.price, 'confidence:', bestMatch.confidence);
        return bestMatch.price;
    }

    console.log('üí∞ No total price found');
    return 0;
}

/**
 * Extract passenger count from PDF text
 */
function extractPassengerCount(text: string): number {
    const passengerPatterns = [
        /(\d+)\s*(?:pasajeros?|passengers?|adultos?|adults?|personas?|people)/gi,
        /(?:pasajeros?|passengers?|adultos?|adults?|personas?|people)\s*:?\s*(\d+)/gi
    ];

    for (const pattern of passengerPatterns) {
        const match = text.match(pattern);
        if (match) {
            const count = parseInt(match[1]);
            if (!isNaN(count) && count > 0) {
                console.log('üë• Extracted passenger count:', count);
                return count;
            }
        }
    }

    console.log('üë• No passenger count found, defaulting to 1');
    return 1;
}

/**
 * Extract currency from PDF text
 */
function extractCurrency(text: string): string {
    const currencyPatterns = [
        /\b(USD|US\$|EUR|ARS|BRL)\b/gi,
        /\$([\d,]+(?:\.\d{2})?)/g
    ];

    for (const pattern of currencyPatterns) {
        const match = text.match(pattern);
        if (match) {
            const currency = match[1]?.toUpperCase() || 'USD';
            console.log('üí± Extracted currency:', currency);
            return currency === 'US$' ? 'USD' : currency;
        }
    }

    console.log('üí± No currency found, defaulting to USD');
    return 'USD';
}

/**
 * Parse flight route string to extract origin and destination
 */
function parseFlightRoute(route: string): { origin: string; destination: string } {
    console.log('üõ´ Parsing route:', route);

    // Remove common separators and clean the route
    const cleanRoute = route.replace(/[‚Üí‚Äì-]/g, '-').trim();

    // Pattern 1: EZE - MIA - PUJ (with connection)
    const connectionMatch = cleanRoute.match(/([A-Z]{3})\s*-\s*[A-Z]{3}\s*-\s*([A-Z]{3})/);
    if (connectionMatch) {
        return {
            origin: connectionMatch[1],
            destination: connectionMatch[2]
        };
    }

    // Pattern 2: EZE - PUJ (direct)
    const directMatch = cleanRoute.match(/([A-Z]{3})\s*-\s*([A-Z]{3})/);
    if (directMatch) {
        return {
            origin: directMatch[1],
            destination: directMatch[2]
        };
    }

    // Pattern 3: City names
    const cityMatch = cleanRoute.match(/(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York)\s*-\s*(Buenos Aires|Madrid|Barcelona|Miami|Punta Cana|Canc√∫n|Nueva York)/i);
    if (cityMatch) {
        return {
            origin: mapCityToCode(cityMatch[1]),
            destination: mapCityToCode(cityMatch[2])
        };
    }

    console.warn('‚ö†Ô∏è Could not parse route:', route);
    return { origin: '', destination: '' };
}

/**
 * Map city names to airport codes
 */
function mapCityToCode(cityName: string): string {
    const cityMap: Record<string, string> = {
        'Buenos Aires': 'EZE',
        'Ezeiza': 'EZE',
        'Jorge Newbery': 'AEP',
        'Aeroparque': 'AEP',
        'Madrid': 'MAD',
        'Barcelona': 'BCN',
        'Miami': 'MIA',
        'Punta Cana': 'PUJ',
        'Canc√∫n': 'CUN',
        'Nueva York': 'JFK'
    };

    return cityMap[cityName] || cityName;
}

/**
 * Map airport codes to city names
 */
function mapCodeToCity(airportCode: string): string {
    const codeMap: Record<string, string> = {
        'BUE': 'Buenos Aires',
        'EZE': 'Buenos Aires',
        'AEP': 'Buenos Aires',
        'MAD': 'Madrid',
        'BCN': 'Barcelona',
        'MIA': 'Miami',
        'PUJ': 'Punta Cana',
        'CUN': 'Canc√∫n',
        'JFK': 'Nueva York',
        'LGA': 'Nueva York',
        'EWR': 'Nueva York',
        'PTY': 'Ciudad de Panam√°',
        'FLL': 'Fort Lauderdale',
        'BOG': 'Bogot√°',
        'LIM': 'Lima',
        'SCL': 'Santiago',
        'GRU': 'S√£o Paulo',
        'GIG': 'R√≠o de Janeiro'
    };

    return codeMap[airportCode] || airportCode;
}

/**
 * Parse date range from PDF text (e.g., "01/11/2025 - 15/11/2025")
 */
function parseDateRange(dateString: string): { departureDate: string; returnDate?: string } {
    if (!dateString) {
        return { departureDate: '2025-11-01' };
    }

    // Handle different separators
    const separators = [' - ', ' / ', ' ‚Äì ', ' ‚Äî ', ' to ', ' al '];
    let dates: string[] = [dateString];

    for (const separator of separators) {
        if (dateString.includes(separator)) {
            dates = dateString.split(separator);
            break;
        }
    }

    const departureDate = parseDate(dates[0]?.trim() || '');
    const returnDate = dates.length > 1 ? parseDate(dates[1]?.trim() || '') : undefined;

    return {
        departureDate,
        returnDate
    };
}

/**
 * Extract airline code from airline name
 */
function extractAirlineCode(airlineName: string): string {
    const airlineCodes: Record<string, string> = {
        'American Airlines': 'AA',
        'United Airlines': 'UA',
        'Delta Air Lines': 'DL',
        'LATAM': 'LA',
        'Aerol√≠neas Argentinas': 'AR',
        'Copa Airlines': 'CM',
        'Avianca': 'AV',
        'Air France': 'AF',
        'Iberia': 'IB',
        'JetSmart': 'JA',
        'Flybondi': 'FO'
    };

    // First try exact match
    if (airlineCodes[airlineName]) {
        return airlineCodes[airlineName];
    }

    // Try partial match
    for (const [name, code] of Object.entries(airlineCodes)) {
        if (airlineName.toLowerCase().includes(name.toLowerCase())) {
            return code;
        }
    }

    // If already looks like a code (2-3 uppercase letters), return it
    if (/^[A-Z]{2,3}$/.test(airlineName)) {
        return airlineName;
    }

    // Fallback: take first 2 letters and uppercase
    return airlineName.substring(0, 2).toUpperCase();
}

/**
 * Calculate flight duration between two times
 */
function calculateFlightDuration(departureTime?: string, arrivalTime?: string): string | null {
    if (!departureTime || !arrivalTime) return null;

    try {
        // Parse times (assuming same day for simplicity)
        const [depHour, depMin] = departureTime.split(':').map(Number);
        const [arrHour, arrMin] = arrivalTime.split(':').map(Number);

        let depMinutes = depHour * 60 + depMin;
        let arrMinutes = arrHour * 60 + arrMin;

        // Handle next day arrival
        if (arrMinutes < depMinutes) {
            arrMinutes += 24 * 60;
        }

        const durationMinutes = arrMinutes - depMinutes;
        const hours = Math.floor(durationMinutes / 60);
        const minutes = durationMinutes % 60;

        return `${hours}h${minutes > 0 ? ` ${minutes}m` : ''}`;
    } catch {
        return null;
    }
}

/**
 * Extract flight information from PdfMonkey template content
 */
function extractFlightsFromPdfMonkeyTemplate(content: string): Array<{
    airline: string,
    route: string,
    price: number,
    dates: string,
    departureTime?: string,
    arrivalTime?: string,
    originCode?: string,
    destinationCode?: string,
    originCity?: string,
    destinationCity?: string
}> {
    const flights = [];

    // Extract airline name - more flexible pattern matching
    const airlineMatch = content.match(/([A-Z\s]+(?:AIRLINES|AIRLINE|GROUP|AEROLINEAS|AEROLINEA)[A-Z\s]*)/i) ||
        content.match(/Vuelos\s+([^$\n]+)/i);
    const airline = airlineMatch ? airlineMatch[1].trim() : 'Aerol√≠nea no especificada';

    // Extract route information - look for airport codes and city names
    const routeMatches = content.match(/([A-Z]{3})\s+([^0-9]+?)\s+(\d{1,2}:\d{2})\s+([A-Z]{3})\s+([^0-9]+?)\s+(\d{1,2}:\d{2})/);
    let route = 'Ruta no especificada';
    let originCode = '';
    let destinationCode = '';
    let departureTime = '';
    let arrivalTime = '';

    if (routeMatches) {
        originCode = routeMatches[1];
        destinationCode = routeMatches[4];
        departureTime = routeMatches[3];
        arrivalTime = routeMatches[6];
        route = `${originCode} ‚Üí ${destinationCode}`;
    } else {
        // Fallback: look for any airport codes
        const simpleRouteMatches = content.match(/([A-Z]{3})\s*(?:--|-|‚Üí|‚áÑ)\s*([A-Z]{3})/g);
        if (simpleRouteMatches && simpleRouteMatches.length > 0) {
            const routeMatch = simpleRouteMatches[0].match(/([A-Z]{3})\s*(?:--|-|‚Üí|‚áÑ)\s*([A-Z]{3})/);
            if (routeMatch) {
                originCode = routeMatch[1];
                destinationCode = routeMatch[2];
                route = `${originCode} ‚Üí ${destinationCode}`;
            }
        }
    }

    // Extract dates - look for date patterns
    const dateMatch = content.match(/(\d{4}-\d{2}-\d{2})/);
    let dates = 'Fechas no especificadas';
    if (dateMatch) {
        dates = dateMatch[1];
    }

    // Extract flight times if not already extracted
    if (!departureTime || !arrivalTime) {
        const timeMatches = content.match(/(\d{1,2}:\d{2})/g);
        if (timeMatches) {
            departureTime = timeMatches[0];
            arrivalTime = timeMatches[1] || timeMatches[0];
        }
    }

    // Extract price - look for price patterns with USD
    const priceMatches = content.match(/(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*USD/i) ||
        content.match(/\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:USD|US\$|\$)/gi);
    let price = 0;
    if (priceMatches) {
        const priceStr = priceMatches[0].match(/(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/);
        if (priceStr) {
            price = parseFloat(priceStr[1].replace(/,/g, ''));
        }
    }

    flights.push({
        airline,
        route,
        price,
        dates,
        departureTime: departureTime || undefined,
        arrivalTime: arrivalTime || undefined,
        originCode,
        destinationCode,
        originCity: mapCodeToCity(originCode),
        destinationCity: mapCodeToCity(destinationCode)
    });

    console.log('‚úàÔ∏è Extracted flights from PdfMonkey template:', flights);
    return flights;
}

/**
 * Extract hotel information from PdfMonkey template content  
 */
function extractHotelsFromPdfMonkeyTemplate(content: string): Array<{
    name: string,
    location: string,
    price: number,
    nights: number
}> {
    const hotels = [];

    // Extract hotel name from template
    const hotelNameMatch = content.match(/Hotel Recomendado[^$]*?([^\n]+(?:Hotel|Resort|Aparthotel)[^\n]*)/i) ||
        content.match(/([^\n]+(?:Hotel|Resort|Aparthotel)[^\n]*)/i);
    const hotelName = hotelNameMatch ? hotelNameMatch[1].trim() : 'Hotel no especificado';

    // Extract location
    const locationMatch = content.match(/(\d+)\s*estrellas[^$]*?([^\n]+(?:Cana|Aires|Madrid|Barcelona|Miami)[^\n]*)/i) ||
        content.match(/([^\n]+(?:Cana|Aires|Madrid|Barcelona|Miami)[^\n]*)/i);
    const location = locationMatch ? (locationMatch[2] || locationMatch[1]).trim() : 'Ubicaci√≥n no especificada';

    // Extract nights duration
    const nightsMatch = content.match(/(\d+)\s*(?:Noche|Noches|noche|noches)/i);
    const nights = nightsMatch ? parseInt(nightsMatch[1]) : 0;

    // Extract hotel price - this might be tricky, look for patterns around hotel section
    const hotelPriceMatches = content.match(/Hotel[^$]*?\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/i);
    let hotelPrice = 0;
    if (hotelPriceMatches) {
        hotelPrice = parseFloat(hotelPriceMatches[1].replace(/,/g, ''));
    }

    hotels.push({
        name: hotelName,
        location,
        price: hotelPrice,
        nights
    });

    console.log('üè® Extracted hotels from PdfMonkey template:', hotels);
    return hotels;
}

/**
 * Extract total price from PdfMonkey template content
 */
function extractTotalPriceFromPdfMonkeyTemplate(content: string): number {
    // Look for total price patterns in our templates
    const totalPatterns = [
        /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*USD/g,
        /(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*USD/g
    ];

    const allPrices = [];
    for (const pattern of totalPatterns) {
        const matches = [...content.matchAll(pattern)];
        matches.forEach(match => {
            const price = parseFloat((match[1] || match[0]).replace(/[^\d.]/g, ''));
            if (!isNaN(price) && price > 0) {
                allPrices.push(price);
            }
        });
    }

    // Return the highest price found (likely the total)
    const totalPrice = allPrices.length > 0 ? Math.max(...allPrices) : 0;
    console.log('üí∞ Extracted total price from PdfMonkey template:', totalPrice);
    return totalPrice;
}

/**
 * Extract passenger count from PdfMonkey template content
 */
function extractPassengersFromPdfMonkeyTemplate(content: string): number {
    const passengerMatch = content.match(/(\d+)\s*(?:Adulto|Adultos|adulto|adultos)/i);
    const passengers = passengerMatch ? parseInt(passengerMatch[1]) : 1;
    console.log('üë• Extracted passengers from PdfMonkey template:', passengers);
    return passengers;
}

/**
 * Extract currency from PdfMonkey template content
 */
function extractCurrencyFromPdfMonkeyTemplate(content: string): string {
    const currencyMatch = content.match(/\b(USD|US\$|EUR|ARS)\b/i);
    const currency = currencyMatch ? currencyMatch[1].toUpperCase().replace('US$', 'USD') : 'USD';
    console.log('üí± Extracted currency from PdfMonkey template:', currency);
    return currency;
}

/**
 * Format parsed data for Starling API
 */
function formatParsedDataForStarling(parsed: any) {
    if (!parsed.flights) return null;

    // Create passenger array for TVC API format
    const passengers = [];
    if ((parsed.flights.adults || 1) > 0) {
        passengers.push({
            Count: parsed.flights.adults || 1,
            Type: 'ADT'
        });
    }
    if ((parsed.flights.children || 0) > 0) {
        passengers.push({
            Count: parsed.flights.children,
            Type: 'CHD'
        });
    }

    // Create legs array for TVC API format
    const legs = [
        {
            DepartureAirportCity: parsed.flights.origin,
            ArrivalAirportCity: parsed.flights.destination,
            FlightDate: parsed.flights.departureDate
        }
    ];

    // Add return leg if this is a round trip
    if (parsed.flights.returnDate) {
        legs.push({
            DepartureAirportCity: parsed.flights.destination,
            ArrivalAirportCity: parsed.flights.origin,
            FlightDate: parsed.flights.returnDate
        });
    }

    return {
        Passengers: passengers,
        Legs: legs,
        Airlines: null
    };
}

/**
 * Search flights using existing Starling/TVC API through Supabase Edge Function
 */
async function searchFlightsWithStarling(starlingRequest: any): Promise<FlightData[]> {
    try {
        console.log('üöÄ Calling existing starling-flights function');
        console.log('üìã Request format:', JSON.stringify(starlingRequest, null, 2));

        // Use the existing starling-flights function with 'searchFlights' action
        const { data, error } = await supabase.functions.invoke('starling-flights', {
            body: {
                action: 'searchFlights',
                data: starlingRequest
            }
        });

        if (error) {
            console.error('‚ùå Starling flights function error:', error);
            throw new Error(`Starling flights error: ${error.message}`);
        }

        if (!data?.success) {
            throw new Error(data?.error || 'Starling flights search failed');
        }

        // Extract flight data from TVC response format
        const tvcFlights = data.data?.Recommendations || [];
        console.log('‚úÖ TVC API response:', tvcFlights.length, 'recommendations found');

        // Transform TVC recommendations to our FlightData format
        const transformedFlights = transformTvcRecommendationsToFlightData(tvcFlights, starlingRequest);

        console.log('‚úÖ Transformed flights:', transformedFlights.length, 'flights ready');
        return transformedFlights;

    } catch (error) {
        console.error('‚ùå Error calling starling-flights function:', error);
        // Fallback to EUROVIPS if Starling fails
        console.log('üîÑ Falling back to EUROVIPS search');
        return await searchAirFares({
            origin: starlingRequest.Legs[0]?.DepartureAirportCity || '',
            destination: starlingRequest.Legs[0]?.ArrivalAirportCity || '',
            departureDate: starlingRequest.Legs[0]?.FlightDate || '',
            returnDate: starlingRequest.Legs[1]?.FlightDate,
            adults: starlingRequest.Passengers?.find((p: any) => p.Type === 'ADT')?.Count || 1,
            children: starlingRequest.Passengers?.find((p: any) => p.Type === 'CHD')?.Count || 0
        });
    }
}

/**
 * Transform TVC Recommendations to FlightData format
 */
function transformTvcRecommendationsToFlightData(recommendations: any[], originalRequest: any): FlightData[] {
    const flights: FlightData[] = [];

    if (!Array.isArray(recommendations)) {
        console.warn('‚ö†Ô∏è TVC recommendations is not an array');
        return flights;
    }

    recommendations.forEach((recommendation, index) => {
        try {
            // Extract basic flight information
            const flightGroups = recommendation.FlightGroups || [];
            const firstGroup = flightGroups[0];

            if (!firstGroup?.Flights?.[0]) {
                console.warn(`‚ö†Ô∏è No flights in recommendation ${index}`);
                return;
            }

            const firstFlight = firstGroup.Flights[0];
            const lastFlight = flightGroups[flightGroups.length - 1]?.Flights?.[0] || firstFlight;

            // Calculate total price
            const totalPrice = recommendation.TotalFare?.TotalPrice || 0;
            const currency = recommendation.TotalFare?.Currency || 'USD';

            // Extract passenger counts
            const adultCount = originalRequest.Passengers?.find((p: any) => p.Type === 'ADT')?.Count || 1;
            const childCount = originalRequest.Passengers?.find((p: any) => p.Type === 'CHD')?.Count || 0;

            // Build flight legs
            const legs = flightGroups.map((group: any) => {
                const flight = group.Flights[0];
                return {
                    departure: {
                        airport_code: flight.OriginAirport || '',
                        city_name: flight.OriginCity || '',
                        datetime: flight.DepartureDateTime || '',
                        terminal: flight.OriginTerminal || ''
                    },
                    arrival: {
                        airport_code: flight.DestinationAirport || '',
                        city_name: flight.DestinationCity || '',
                        datetime: flight.ArrivalDateTime || '',
                        terminal: flight.DestinationTerminal || ''
                    },
                    duration: flight.FlightDuration || '',
                    flight_number: flight.FlightNumber || '',
                    aircraft: flight.AircraftType || '',
                    airline_code: flight.AirlineCode || ''
                };
            });

            const transformedFlight: FlightData = {
                id: `tvc_${recommendation.RecommendationId || index}`,
                airline: {
                    code: firstFlight.AirlineCode || '',
                    name: firstFlight.AirlineName || 'Unknown Airline'
                },
                price: {
                    amount: totalPrice,
                    currency: currency
                },
                departure_date: originalRequest.Legs[0]?.FlightDate || '',
                return_date: originalRequest.Legs[1]?.FlightDate,
                adults: adultCount,
                childrens: childCount,
                legs: legs
            };

            flights.push(transformedFlight);

        } catch (err) {
            console.error(`‚ùå Error transforming TVC recommendation ${index}:`, err);
        }
    });

    console.log(`‚úÖ Successfully transformed ${flights.length} flights from ${recommendations.length} TVC recommendations`);
    return flights;
}

/**
 * Calculate total flight duration from legs
 */
function calculateTotalDuration(legs: any[]): string {
    if (!legs || legs.length === 0) return '';

    // Simple implementation - just return the duration of the first leg
    // In a real implementation, you'd calculate the total travel time including layovers
    return legs[0]?.duration || '';
}

/**
 * Extract baggage information from TVC recommendation
 */
function extractBaggageInfo(recommendation: any): string {
    // Extract baggage info if available in the TVC response
    const baggage = recommendation.BaggageAllowance || recommendation.Baggage;
    if (baggage) {
        if (typeof baggage === 'string') return baggage;
        if (baggage.CheckedBaggage) return `${baggage.CheckedBaggage} checked`;
        if (baggage.CabinBaggage) return `${baggage.CabinBaggage} cabin`;
    }
    return 'Standard baggage allowance';
}
